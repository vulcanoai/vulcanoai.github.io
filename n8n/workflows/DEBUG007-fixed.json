{
  "name": "DEBUG007",
  "nodes": [
    {
      "parameters": {
        "mode": "mergeByPosition",
        "options": {}
      },
      "id": "aed0f2f9-46fa-4ed6-9cc8-d3396788bef9",
      "name": "INDEX_SHA_MERGE3",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        -704,
        624
      ]
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {}
          ]
        }
      },
      "id": "4275a320-a3d3-4400-909f-c68497ac90ca",
      "name": "AUTOPILOT (hourly)",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1,
      "position": [
        -2544,
        304
      ],
      "notes": "Runs every hour. You can change to 30min or daily."
    },
    {
      "parameters": {
        "jsCode": "// BUILD_DAILY_INDEX \u2014 build per-day index of entries; skip if no articles\nconst articles = Array.isArray($json.articles) ? $json.articles : [];\nif (!articles.length) return [];\nconst dateStr = (new Date().toISOString()).slice(0,10);\n// Lightweight index with summaries for navigation\nconst byTopic = {};\nconst byCountry = {};\nfor (const a of articles){\n  for (const t of (a.topics||[])){ byTopic[t] = (byTopic[t]||0) + 1; }\n  const c = a.country || 'Regional'; byCountry[c] = (byCountry[c]||0) + 1;\n}\nconst index = { version: 'v1.0', date: dateStr, count: articles.length, topics: byTopic, countries: byCountry, generated_at: new Date().toISOString() };\nconst payload = JSON.stringify(index, null, 2);\nconst content = Buffer.from(payload).toString('base64');\n// We derive base from BUILD_PARAMS for owner/repo/branch (use $items, not $(...))\nfunction item(n){ try{ const it=$items(n,0,0); return it && it.json ? it.json : null; }catch(_){ return null; } }\nconst pItem = item('BUILD_PARAMS') || {};\nconst params = (pItem.params) || {};\nconst owner = params.repoOwner || 'vulcanoai';\nconst repo  = params.repoName  || 'vulcanoai.github.io';\nconst branch= params.branch     || 'main';\nconst base  = `https://api.github.com/repos/${owner}/${repo}/contents`;\nconst path = `data/entries/${dateStr}/index.json`;\nconst message = `chore(index): daily entries index ${dateStr}`;\nreturn [ { json: { base, branch, path, content, payload, message } } ];"
      },
      "id": "b3e32b2e-ca51-4a55-a737-cad0ecb6362f",
      "name": "BUILD_DAILY_INDEX",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1136,
        528
      ]
    },
    {
      "parameters": {
        "url": "={{$json.base}}/{{ $json.path }}?ref={{$json.branch}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            }
          ]
        },
        "options": {
          "timeout": 60000,
          "ignoreResponseCode": true
        }
      },
      "id": "57d8794a-3552-4deb-8a82-e692b95920e1",
      "name": "GITHUB_GET_DAILY_INDEX_SHA",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -912,
        528
      ],
      "alwaysOutputData": true,
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// BUILD_PUT_DAILY_INDEX \u2014 merge meta + sha from both inputs into PUT body\nconst all = $input.all();\nconst meta = all.find(i => i.json && i.json.base && i.json.path);\nconst resp = all.find(i => i.json && (i.json.sha || (i.json.body && i.json.body.sha) || (i.json.data && i.json.data.sha)));\nif (!meta) return [];\nconst { base, branch, path, content, message } = meta.json;\nlet sha = resp ? (resp.json.sha || (resp.json.body && resp.json.body.sha) || (resp.json.data && resp.json.data.sha)) : undefined;\nconst body = { message, content, branch };\nif (sha) body.sha = sha;\nreturn [{ json: { url: `${base}/${path}`, body } }];\n"
      },
      "id": "4d92a173-d700-4dd3-a4fa-a9c6d1184321",
      "name": "BUILD_PUT_DAILY_INDEX",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -528,
        592
      ]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.url }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.body }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "7f7a4c43-51f2-4065-892d-4426bcebf763",
      "name": "GITHUB_PUT_DAILY_INDEX",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -320,
        704
      ],
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      }
    },
    {
      "parameters": {
        "url": "={{$json.base}}/{{ $json.pathSnapshot }}?ref={{$json.branch}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            }
          ]
        },
        "options": {
          "timeout": 60000,
          "ignoreResponseCode": true
        }
      },
      "id": "ed066eb7-f7bf-4d5c-8928-e0f36e737178",
      "name": "GITHUB_GET_SNAPSHOT_SHA",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -944,
        -160
      ],
      "alwaysOutputData": true,
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      },
      "continueOnFail": true,
      "notes": "Read snapshot file to get sha if it exists."
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "f0c79f59-c04c-4052-8683-950101645999",
        "responseMode": "responseNode",
        "options": {
          "rawBody": true
        }
      },
      "id": "19c10482-1db1-4222-977f-6613eb14053f",
      "name": "FEED_IN",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -2544,
        512
      ],
      "webhookId": "f0c79f59-c04c-4052-8683-950101645999",
      "notes": "Webhook to trigger on-demand runs with custom prompt/params."
    },
    {
      "parameters": {},
      "id": "846c7f20-db0b-4930-83cf-638c111561a0",
      "name": "START",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        -2320,
        400
      ],
      "notes": "Merge schedule + webhook into a single flow"
    },
    {
      "parameters": {
        "jsCode": "// BUILD_PARAMS: parse webhook body or defaults for autopilot\nconst isWebhook = !!$json.headers;\nlet src = $json.body || $json || {};\nif (typeof src === 'string') { try { src = JSON.parse(src); } catch { src = {}; } }\nif (!src || typeof src !== 'object') src = {};\n\n// Query defaults (tunable)\nconst q = src.prompt || src.query || 'artificial intelligence OR inteligencia artificial OR IA latinoam\u00e9rica OR latin america (last 24 hours)';\nconst timeWindowHours = Number(src.time_window_hours ?? 24);\nconst languages = Array.isArray(src.languages) ? src.languages : ['es','pt'];\nconst minSources = Number(src.min_sources ?? 1);\n\n// Publication settings (no secrets here; set in n8n secrets)\nconst repoOwner = src.repo_owner || 'vulcanoai';\nconst repoName  = src.repo_name  || 'vulcanoai.github.io';\nconst branch    = src.branch     || 'main';\nconst pathLatest   = src.path_latest   || 'data/feed-latest.json';\nconst pathSnapshot = src.path_snapshot || `data/feed-${new Date().toISOString().slice(0,10)}.json`;\n\n// Country/topic rules (lightweight heuristics)\nconst countryKeywords = { 'M\u00e9xico': ['m\u00e9xico','cdmx','guadalajara','monterrey'], 'Colombia': ['colombia','bogot\u00e1','medell\u00edn','cali'], 'Brasil': ['brasil','brazil','s\u00e3o paulo','rio de janeiro'], 'Argentina': ['argentina','buenos aires','c\u00f3rdoba'], 'Chile': ['chile','santiago','valpara\u00edso'], 'Per\u00fa': ['per\u00fa','lima'], 'Uruguay': ['uruguay','montevideo'], 'Ecuador': ['ecuador','quito','guayaquil'], 'Panam\u00e1': ['panam\u00e1','ciudad de panam\u00e1'], 'Venezuela': ['venezuela','caracas'], 'Paraguay': ['paraguay','asunci\u00f3n'], 'Bolivia': ['bolivia','la paz','santa cruz'], 'Costa Rica': ['costa rica','san jos\u00e9'], 'Rep\u00fablica Dominicana': ['rep\u00fablica dominicana','santo domingo'] };\nconst topicKeywords = { 'Startups': ['startup','emprendimiento','seed','series a','ronda'], 'Inversi\u00f3n': ['inversi\u00f3n','funding','capital','vc'], 'Regulaci\u00f3n': ['regulaci\u00f3n','ley','marco','norma','pol\u00edtica'], 'Investigaci\u00f3n': ['investigaci\u00f3n','universidad','estudio','paper'], 'Empresas': ['empresa','corporativo','alianza','lanzamiento'], 'Gobierno': ['gobierno','ministerio','agencia','pol\u00edtica p\u00fablica'], 'Educaci\u00f3n': ['educaci\u00f3n','beca','curso','programa'], 'Salud': ['salud','hospital','m\u00e9dica','diagn\u00f3stico'] };\nconst sentimentIndicators = { positive: ['\u00e9xito','crecimiento','innovaci\u00f3n','logro','expansi\u00f3n'], negative: ['crisis','problema','falla','recorte','fraude'], neutral:  ['anuncia','presenta','informa','publica'] };\n\nconst feedMaxLatest = Number(src.feed_max_latest ?? 200);\nconst feedMaxSnapshot = Number(src.feed_max_snapshot ?? 500);\nreturn [{ json: { params: { q, timeWindowHours, languages, minSources, repoOwner, repoName, branch, pathLatest, pathSnapshot, feedMaxLatest, feedMaxSnapshot, countryKeywords, topicKeywords, sentimentIndicators } } }];\n"
      },
      "id": "1b224db9-4a2b-4e65-84ce-6c82c63c3d14",
      "name": "BUILD_PARAMS",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2112,
        144
      ]
    },
    {
      "parameters": {
        "model": "grok-3-fast",
        "options": {}
      },
      "id": "880106b1-0771-4edb-916d-8fdc966a15f9",
      "name": "xAI Grok Chat Model",
      "type": "@n8n/n8n-nodes-langchain.lmChatXAiGrok",
      "typeVersion": 1,
      "position": [
        -1936,
        464
      ],
      "credentials": {
        "xAiApi": {
          "id": "H0GQCuRkHVUlEFKY",
          "name": "xAi account"
        }
      }
    },
    {
      "parameters": {
        "sessionKey": "latam-news"
      },
      "id": "5e424792-12dc-4c7b-8511-53569de956d4",
      "name": "Aether Memory",
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1,
      "position": [
        -1840,
        560
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "Eres un agente de investigaci\u00f3n period\u00edstica para IA en LATAM.\nObjetivo: encontrar noticias verificables de las \u00faltimas {{ $items('BUILD_PARAMS',0,0).json.params.timeWindowHours }} horas. Devuelve SOLO JSON estricto.\nEsquema:\n{\n  \"articles\": [\n    {\n      \"title\": \"...\",\n      \"summary\": \"...\",\n      \"url\": \"https://...\",\n      \"source\": \"medio o sitio\",\n      \"source_url\": \"https://...\",\n      \"country\": \"M\u00e9xico|Colombia|Regional|...\",\n      \"topics\": [\"Startups\",\"Regulaci\u00f3n\",...],\n      \"language\": \"es|pt\",\n      \"published_at\": \"ISO-8601\",\n      \"relevance\": 0-10,\n      \"sentiment\": \"positive|neutral|negative\",\n      \"author\": \"...\",\n      \"curator\": \"Luciano AI\"\n    }\n  ]\n}\nCriterios: incluye s\u00f3lo art\u00edculos con URL p\u00fablica v\u00e1lida y fecha dentro del rango. No inventes datos. Prioriza fuentes confiables en espa\u00f1ol/portugu\u00e9s de LATAM. Responde en espa\u00f1ol.",
        "options": {}
      },
      "id": "e342053c-e1bb-41bd-a626-c753b1ce36bd",
      "name": "AGENT \u2014 Research",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        -1936,
        144
      ]
    },
    {
      "parameters": {
        "jsCode": "// Parse strict/loose JSON from agent without regex escapes\nconst raw = $json.text ?? $json.output ?? $json;\nconst s = typeof raw==='string' ? raw : JSON.stringify(raw);\nconst i = s.indexOf('{');\nconst j = s.lastIndexOf('}');\nif (i < 0 || j <= i) throw new Error('Agent did not return JSON');\nlet obj;\ntry { obj = JSON.parse(s.slice(i, j+1)); } catch(e){ throw new Error('Invalid JSON from agent'); }\nif(!obj || !Array.isArray(obj.articles)) obj = { articles: [] };\nreturn [{ json: obj }];"
      },
      "id": "45194ab0-6f41-495d-b585-d28e5eaef83f",
      "name": "PARSE_AGENT_JSON (safe)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1520,
        144
      ]
    },
    {
      "parameters": {
        "jsCode": "// Validate + normalize + dedupe + recency filter (robust)\n// 1) Read params safely\nlet params;\ntry { const pA = $items('BUILD_PARAMS', 0, 0); if (pA && pA.json && pA.json.params) { params = pA.json.params; } } catch {}\nif (!params) { try { const pB = $items('BUILD_PARAMS1', 0, 0); if (pB && pB.json && pB.json.params) { params = pB.json.params; } } catch {} }\nif (!params) { params = $json.params || {}; }\n// Defaults\nparams.repoOwner = params.repoOwner || 'vulcanoai';\nparams.repoName  = params.repoName  || 'vulcanoai.github.io';\nparams.branch    = params.branch    || 'main';\nparams.pathLatest   = params.pathLatest   || 'data/feed-latest.json';\nparams.pathSnapshot = params.pathSnapshot || `data/feed-${new Date().toISOString().slice(0,10)}.json`;\nparams.timeWindowHours   = Number(params.timeWindowHours ?? 24);\nparams.maxBackfillHours  = Number(params.maxBackfillHours ?? 336); // ~14 days\nparams.minItems          = Number(params.minItems ?? 1);\nparams.backfillIfEmpty   = params.backfillIfEmpty !== false;\nparams.languages = Array.isArray(params.languages) ? params.languages : ['es','pt'];\n\n// 2) Helpers\nconst allowLangs = new Set((params.languages||[]).map(l=>String(l).slice(0,2).toLowerCase()));\nconst now = Date.now();\nfunction withinHours(ts, hours){ const t=new Date(ts).getTime(); return isFinite(t) && (now - t) <= hours*3600*1000; }\nfunction dedupe(items){ const seen=new Set(); const out=[]; for(const it of items){ const key=it.url||it.id; if(!key||seen.has(key)) continue; seen.add(key); out.push(it); } return out; }\nfunction normalize(a){\n  const title = a.title || a.titulo || '';\n  const url = a.url || a.link || '';\n  let lang = (a.language || a.idioma || '').toString().slice(0,2).toLowerCase();\n  if(!lang) lang = 'es';\n  let pub = a.published_at || a.fecha || new Date().toISOString();\n  const d = new Date(pub);\n  if(!isFinite(d.getTime())) pub = new Date().toISOString();\n  const topics = Array.isArray(a.topics) ? a.topics : (Array.isArray(a.temas) ? a.temas : []);\n  return {\n    id: a.id || url || title,\n    title, url,\n    summary: a.summary || a.resumen || '',\n    source: a.source || a.fuente || '',\n    source_url: a.source_url || a.fuente_url || '',\n    country: a.country || a.pais || 'Regional',\n    topics,\n    language: lang,\n    published_at: pub,\n    relevance: a.relevance || a.relevancia || 0,\n    sentiment: a.sentiment || a.sentimiento || 'neutral',\n    author: a.author || a.autor || '',\n    curator: a.curator || a.curador || 'Luciano AI'\n  };\n}\nfunction filterWindow(items, hours){\n  const arr = [];\n  for (const it of items){\n    if (!it || !it.url || !it.title) continue;\n    if (!withinHours(it.published_at, hours)) continue;\n    const lang = (it.language||'').toString().slice(0,2).toLowerCase();\n    if (allowLangs.size && lang && !allowLangs.has(lang)) continue;\n    arr.push(it);\n  }\n  return arr;\n}\n\n// 3) Process\nconst baseRaw = Array.isArray($json.articles) ? $json.articles : [];\nconst normalized = baseRaw.map(normalize).filter(x=>x && x.url && x.title);\nconst base = dedupe(normalized);\nlet windowH = params.timeWindowHours;\nlet out = filterWindow(base, windowH);\nlet usedBackfill = false;\nif (out.length < params.minItems && params.backfillIfEmpty){\n  let h = Math.min(params.maxBackfillHours, Math.max(windowH*2, 48));\n  while (h <= params.maxBackfillHours && out.length < params.minItems){\n    out = filterWindow(base, h);\n    if (out.length >= params.minItems){ windowH = h; usedBackfill = true; break; }\n    if (h === params.maxBackfillHours) break;\n    h = Math.min(params.maxBackfillHours, h*2);\n  }\n}\n\n// 4) Sort, cap, return\nout.sort((a,b)=> new Date(b.published_at) - new Date(a.published_at) || (b.relevance||0)-(a.relevance||0));\nout.splice(48);\nreturn [{ json: { articles: out, count: out.length, timestamp: new Date().toISOString(), params: { ...params, appliedWindowHours: windowH, usedBackfill } } }];"
      },
      "id": "1cf059c3-89fd-4113-9a9f-4e498a0fb2db",
      "name": "VALIDATE_DEDUPE_SORT",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1328,
        144
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare GitHub upload body (base64) and URLs; skip if no articles\nfunction getNodeItemSafe(name){ try { const it = $items(name, 0, 0); if (it && it.json && !(it.json && it.json.name==='Error')) return it; } catch(e) { return null; } return null; }\nconst pA = getNodeItemSafe('BUILD_PARAMS');\nconst pB = getNodeItemSafe('BUILD_PARAMS1');\nlet params = (pA && pA.json && pA.json.params) || (pB && pB.json && pB.json.params) || $json.params || {};\n// Defaults\nparams.repoOwner = params.repoOwner || 'vulcanoai';\nparams.repoName  = params.repoName  || 'vulcanoai.github.io';\nparams.branch    = params.branch    || 'main';\nparams.pathLatest   = params.pathLatest   || 'data/feed-latest.json';\nparams.pathSnapshot = params.pathSnapshot || `data/feed-${new Date().toISOString().slice(0,10)}.json`;\nconst { repoOwner, repoName, branch, pathLatest, pathSnapshot } = params;\nconst items = Array.isArray($json.articles) ? $json.articles : [];\nif (!items.length) return [];\nconst payload = JSON.stringify({ version: 'v1.0', articles: items }, null, 2);\nconst content = Buffer.from(payload).toString('base64');\nconst base = `https://api.github.com/repos/${repoOwner}/${repoName}/contents`;\nreturn [{ json: { base, branch, pathLatest, pathSnapshot, content, payload, message: `chore(feed): update ${pathLatest} (${new Date().toISOString()})` } }];"
      },
      "id": "2268b3e2-a524-4182-8abd-df1016b4e8f3",
      "name": "BUILD_GH_BODY",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1120,
        208
      ]
    },
    {
      "parameters": {
        "url": "={{$json.base}}/{{ $json.pathLatest }}?ref={{$json.branch}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            }
          ]
        },
        "options": {
          "timeout": 60000,
          "ignoreResponseCode": true
        }
      },
      "id": "de352ec9-7ced-4d8e-af6b-1ca8535f9bed",
      "name": "GITHUB_GET_LATEST_SHA",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -960,
        160
      ],
      "alwaysOutputData": true,
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      },
      "continueOnFail": true,
      "notes": "Read current file to get sha (update vs create)."
    },
    {
      "parameters": {
        "jsCode": "function item(n){ try{ const it=$items(n,0,0); return it && it.json ? it.json : null; }catch(_){ return null; } }\nconst ghBody = item('BUILD_GH_BODY') || {};\nconst pItem = item('BUILD_PARAMS') || item('BUILD_PARAMS1');\nconst params = (pItem && pItem.params) || ($json.params || {});\n\n// From immediate upstream (GITHUB_GET_LATEST_SHA)\nconst resp = ($json && typeof $json === 'object')\n  ? ($json.body && typeof $json.body === 'object' ? $json.body\n     : ($json.data && typeof $json.data === 'object' ? $json.data : $json))\n  : {};\nconst sha = typeof resp.sha === 'string' ? resp.sha : undefined;\nconst existingContentB64 = typeof resp.content === 'string' ? resp.content : undefined;\n\nfunction decodeContent(b64){ try{ const j=JSON.parse(Buffer.from(b64, 'base64').toString('utf8')); return Array.isArray(j)? j : (j && j.articles) ? j.articles : []; }catch(_){ return []; } }\n// Defaults\nconst owner = params.repoOwner || 'vulcanoai';\nconst repo = params.repoName || 'vulcanoai.github.io';\nconst branch= ghBody.branch || params.branch || 'main';\nconst pathLatest = ghBody.pathLatest || params.pathLatest || 'data/feed-latest.json';\nconst base = ghBody.base || ('https://api.github.com/repos/' + owner + '/' + repo + '/contents');\n\n// New items from ghBody.content (base64-encoded array)\nconst newItems = (()=>{ try{ const j=JSON.parse(Buffer.from(ghBody.content||'', 'base64').toString('utf8')); return Array.isArray(j)? j : (j && j.articles)? j.articles : []; }catch(_){ return []; }})();\n// Existing items from GET (if file exists)\nconst oldItems = existingContentB64 ? decodeContent(existingContentB64) : [];\n\nif (!Array.isArray(oldItems) || oldItems.length===0) { /* ok */ }\nif (!Array.isArray(newItems) || newItems.length===0) { /* ok */ }\nif ((oldItems?.length||0)===0 && (newItems?.length||0)===0) { return []; }\n// Union by URL (preserve prior, add new uniques)\nconst seen=new Set();\nconst merged=[];\nfor(const it of oldItems){ if(it && it.url && !seen.has(it.url)){ seen.add(it.url); merged.push(it); } }\nfor(const it of newItems){ if(it && it.url && !seen.has(it.url)){ seen.add(it.url); merged.push(it); } }\n// Sort newest first, cap 200\nmerged.sort((a,b)=> new Date(b.published_at)-new Date(a.published_at) || (b.relevance||0)-(a.relevance||0));\nconst cap = Number((item('BUILD_PARAMS')||{}).params?.feedMaxLatest||200);\nmerged.splice(cap);\nconst content = Buffer.from(JSON.stringify({ version:'v1.0', articles: merged }, null, 2)).toString('base64');\nconst message = ghBody.message || ('chore(feed): update ' + pathLatest + ' (' + new Date().toISOString() + ')');\nconst body = { message, content, branch };\nif (sha) body.sha = sha;\nreturn [{ json: { url: base + '/' + pathLatest, body: body } }];\n"
      },
      "id": "cdd49e73-b28c-4e03-8e25-e424a2e142d5",
      "name": "BUILD_PUT_LATEST",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -352,
        -16
      ]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "={{$json.url}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.body }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "1e743034-f23c-4a29-9428-9e9e95a95606",
      "name": "GITHUB_PUT_LATEST",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -176,
        -48
      ],
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      },
      "notes": "Writes/updates data/feed-latest.json in repo."
    },
    {
      "parameters": {
        "jsCode": "function item(n){ try{ const it=$items(n,0,0); return it && it.json ? it.json : null; }catch(_){ return null; } }\nconst ghBody = item('BUILD_GH_BODY') || {};\nconst pItem = item('BUILD_PARAMS') || item('BUILD_PARAMS1');\nconst params = (pItem && pItem.params) || ($json.params || {});\n\n// From immediate upstream (GITHUB_GET_SNAPSHOT_SHA)\nconst resp = ($json && typeof $json === 'object')\n  ? ($json.body && typeof $json.body === 'object' ? $json.body\n     : ($json.data && typeof $json.data === 'object' ? $json.data : $json))\n  : {};\nconst sha = typeof resp.sha === 'string' ? resp.sha : undefined;\nconst existingContentB64 = typeof resp.content === 'string' ? resp.content : undefined;\n\nfunction decodeContent(b64){ try{ const j=JSON.parse(Buffer.from(b64, 'base64').toString('utf8')); return Array.isArray(j)? j : (j && j.articles) ? j.articles : []; }catch(_){ return []; } }\nconst owner = params.repoOwner || 'vulcanoai';\nconst repo = params.repoName || 'vulcanoai.github.io';\nconst branch= ghBody.branch || params.branch || 'main';\nconst pathSnapshot = ghBody.pathSnapshot || params.pathSnapshot || ('data/feed-' + new Date().toISOString().slice(0,10) + '.json');\nconst base = ghBody.base || ('https://api.github.com/repos/' + owner + '/' + repo + '/contents');\n\nconst newItems = (()=>{ try{ const j=JSON.parse(Buffer.from(ghBody.content||'', 'base64').toString('utf8')); return Array.isArray(j)? j : (j && j.articles)? j.articles : []; }catch(_){ return []; }})();\nconst oldItems = existingContentB64 ? decodeContent(existingContentB64) : [];\n\nif (!Array.isArray(oldItems) || oldItems.length===0) { /* ok */ }\nif (!Array.isArray(newItems) || newItems.length===0) { /* ok */ }\nif ((oldItems?.length||0)===0 && (newItems?.length||0)===0) { return []; }\nconst seen=new Set();\nconst merged=[];\nfor(const it of oldItems){ if(it && it.url && !seen.has(it.url)){ seen.add(it.url); merged.push(it); } }\nfor(const it of newItems){ if(it && it.url && !seen.has(it.url)){ seen.add(it.url); merged.push(it); } }\nmerged.sort((a,b)=> new Date(b.published_at)-new Date(a.published_at) || (b.relevance||0)-(a.relevance||0));\nconst cap = Number((item('BUILD_PARAMS')||{}).params?.feedMaxSnapshot||500);\nmerged.splice(cap);\nconst content = Buffer.from(JSON.stringify({ version:'v1.0', articles: merged }, null, 2)).toString('base64');\nconst message = 'chore(feed): snapshot ' + pathSnapshot;\nconst body = { message, content, branch };\nif (sha) body.sha = sha;\nreturn [{ json: { url: base + '/' + pathSnapshot, body: body } }];\n"
      },
      "id": "ea62e6f1-7f0a-4eff-a6e6-c826dfaea574",
      "name": "BUILD_PUT_SNAPSHOT",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -720,
        -208
      ]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "={{$json.url}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.body }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "0e730e73-f1a4-4dcb-a6ef-eaa141d7dd5e",
      "name": "GITHUB_PUT_SNAPSHOT",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -544,
        -224
      ],
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      },
      "notes": "Writes daily snapshot: data/feed-YYYY-MM-DD.json"
    },
    {
      "parameters": {
        "options": {
          "responseCode": 200
        }
      },
      "id": "41359d72-2f29-4b4a-ab19-5b3c65a245fe",
      "name": "RESPOND (FEED_IN)",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        0,
        -48
      ]
    },
    {
      "parameters": {
        "jsCode": "// BUILD_ENTRY_FILES \u2014 produce one GitHub file per article (persistent entries); skip if no articles\nfunction item(n){ try{ const it=$items(n,0,0); return it && it.json ? it.json : null; }catch(_){ return null; } }\nconst pItem = item('BUILD_PARAMS') || {};\nconst params = (pItem.params) || {};\nconst owner = params.repoOwner || 'vulcanoai';\nconst repo  = params.repoName  || 'vulcanoai.github.io';\nconst branch= params.branch     || 'main';\nconst base  = `https://api.github.com/repos/${owner}/${repo}/contents`;\n// Prefer input items, fallback to $json.articles if needed\nconst inputItems = $input.all();\nlet arts = Array.isArray(inputItems[0]?.json?.articles) ? inputItems[0].json.articles : (Array.isArray($json.articles) ? $json.articles : []);\nif (!arts.length) return [];\n\nfunction slugify(s){ return (s||'').toString().normalize('NFD').replace(/[\\u0300-\\u036f]/g,'').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'').slice(0,80); }\nfunction shortHash(s){ let h=0; for (let i=0;i<(s||'').length;i++){ h=((h<<5)-h) + s.charCodeAt(i); h|=0; } return ('00000000'+(h>>>0).toString(16)).slice(-8); }\n\nconst out = [];\nfor (const a of arts){\n  if (!a || !a.url || !a.title) continue;\n  const dateStr = (a.published_at || new Date().toISOString()).slice(0,10);\n  const slug = slugify(a.title);\n  const uniq = shortHash(a.url);\n  const path = `data/entries/${dateStr}/${slug}-${uniq}.json`;\n  const payload = JSON.stringify({\n    version: 'v1.0',\n    id: a.id || `${dateStr}-${slug}-${uniq}`,\n    title: a.title, summary: a.summary || '', url: a.url,\n    source: a.source || '', source_url: a.source_url || '',\n    country: a.country || 'Regional', topics: a.topics || [],\n    language: a.language || 'es', published_at: a.published_at || new Date().toISOString(),\n    relevance: a.relevance || 0, sentiment: a.sentiment || 'neutral',\n    author: a.author || '', curator: a.curator || 'Luciano AI'\n  }, null, 2);\n  const content = Buffer.from(payload).toString('base64');\n  const message = `feat(news): add entry ${slug} (${dateStr})`;\n  out.push({ json: { base, branch, path, content, payload, message } });\n}\nreturn out;"
      },
      "id": "61e2d55a-ddba-439e-9f4f-37b8b2332c10",
      "name": "BUILD_ENTRY_FILES",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1136,
        352
      ]
    },
    {
      "parameters": {
        "url": "={{$json.base}}/{{ $json.path }}?ref={{$json.branch}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            }
          ]
        },
        "options": {
          "timeout": 60000,
          "ignoreResponseCode": true
        }
      },
      "id": "d05e53be-23e9-4ba0-97b7-84afaeb3a7c8",
      "name": "GITHUB_GET_ENTRY_SHA",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -912,
        352
      ],
      "alwaysOutputData": true,
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      },
      "continueOnFail": true,
      "notes": "Read entry file sha if exists (per-article)."
    },
    {
      "parameters": {
        "mode": "mergeByPosition",
        "options": {}
      },
      "id": "94d33525-2806-4fa1-9e24-76033ef8b0f3",
      "name": "ENTRY_SHA_MERGE",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        -528,
        336
      ]
    },
    {
      "parameters": {
        "jsCode": "// BUILD_PUT_ENTRY \u2014 assemble PUT body for per-article file\\nconst r = ($json && typeof $json === 'object') ? ($json.body && typeof $json.body === 'object' ? $json.body : ($json.data && typeof $json.data === 'object' ? $json.data : $json)) : {};\nconst sha = (typeof r.sha === 'string') ? r.sha : undefined;\\nconst { base, branch, path, content, message } = $json;\\nconst body = { message, content, branch };\\nif (sha) body.sha = sha;\\nreturn [{ json: { url: `${base}/${path}`, body } }];"
      },
      "id": "e930b62a-c14c-4474-9e81-39de137f7113",
      "name": "BUILD_PUT_ENTRY",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        112,
        112
      ]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "={{$json.url}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.body }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "1c3d2461-f86b-42a8-ab9e-a36988c71279",
      "name": "GITHUB_PUT_ENTRY",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        592,
        384
      ],
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      },
      "notes": "Create/update per-article persistent entry under data/entries/YYYY-MM-DD/slug-hash.json"
    },
    {
      "parameters": {
        "jsCode": "// DIRECT_NORMALIZE \u2014 minimal normalization, never drop valid items\nconst arr = Array.isArray($json.articles) ? $json.articles : [];\nfunction norm(a){\n  const title = a.title || a.titulo || '';\n  const url = a.url || a.link || '';\n  if (!title || !url) return null;\n  const lang = (a.language || a.idioma || 'es').toString().slice(0,2).toLowerCase();\n  let pub = a.published_at || a.fecha || new Date().toISOString();\n  const d = new Date(pub); if (!isFinite(d)) pub = new Date().toISOString();\n  const topics = Array.isArray(a.topics) ? a.topics : (Array.isArray(a.temas) ? a.temas : []);\n  return {\n    id: a.id || url || title,\n    title, summary: a.summary || a.resumen || '', url,\n    source: a.source || a.fuente || '', source_url: a.source_url || a.fuente_url || '',\n    country: a.country || a.pais || 'Regional', topics,\n    language: lang, published_at: pub,\n    relevance: a.relevance || a.relevancia || 0, sentiment: a.sentiment || a.sentimiento || 'neutral',\n    author: a.author || a.autor || '', curator: a.curator || a.curador || 'Luciano AI'\n  };\n}\nconst articles = arr.map(norm).filter(Boolean);\nreturn [{ json: { articles, count: articles.length, timestamp: new Date().toISOString() } }];"
      },
      "id": "a56a81bd-ca08-4a9c-898f-c4289872f832",
      "name": "DIRECT_NORMALIZE",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1584,
        512
      ]
    },
    {
      "parameters": {
        "jsCode": "// BUILD_RUN_FILE \u2014 unique snapshot per trigger run\nfunction item(n){ try{ const it=$items(n,0,0); return it && it.json ? it.json : null; }catch(_){ return null; } }\nconst p = item('BUILD_PARAMS') || {};\nconst params = p.params || {};\nconst owner = params.repoOwner || 'vulcanoai';\nconst repo  = params.repoName  || 'vulcanoai.github.io';\nconst branch= params.branch     || 'main';\nconst base  = `https://api.github.com/repos/${owner}/${repo}/contents`;\nconst runId = (new Date().toISOString()).replace(/[:.]/g,'-');\nconst path  = `data/runs/${runId}.json`;\nconst payload = JSON.stringify({ version: 'v1.0', articles: $json.articles || [], count: $json.count || 0, timestamp: $json.timestamp, params }, null, 2);\nconst content = Buffer.from(payload).toString('base64');\nconst message = `feat(run): snapshot ${runId} (${($json.count||0)} articles)`;\nreturn [{ json: { url: `${base}/${path}`, body: { message, content, branch } } }];"
      },
      "id": "4c04fd4a-f59f-46bf-8b5b-4c2c92b38f45",
      "name": "BUILD_RUN_FILE",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1456,
        928
      ]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "={{$json.url}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.body }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "9d77a82a-3f9d-4507-bcd2-7ca1d7e513c6",
      "name": "GITHUB_PUT_RUN",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -1168,
        896
      ],
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// BUILD_MASTER_INDEX \u2014 by-topic and by-country (today); emits two items\nconst arts = Array.isArray($json.articles) ? $json.articles : [];\nconst topics = new Map();\nconst countries = new Map();\nfor (const a of arts){\n  for (const t of (a.topics||[])) topics.set(t, (topics.get(t)||0)+1);\n  const c = a.country || 'Regional'; countries.set(c, (countries.get(c)||0)+1);\n}\nconst byTopic = Object.fromEntries([...topics.entries()].sort());\nconst byCountry = Object.fromEntries([...countries.entries()].sort());\nconst gen = new Date().toISOString();\nfunction paramsOf(name){ try{ const it=$items(name,0,0); return it && it.json && it.json.params ? it.json.params : {}; }catch(_){ return {}; } }\nconst p = paramsOf('BUILD_PARAMS');\nconst owner=p.repoOwner||'vulcanoai'; const repo=p.repoName||'vulcanoai.github.io'; const branch=p.branch||'main';\nconst base=`https://api.github.com/repos/${owner}/${repo}/contents`;\nconst tPayload = JSON.stringify({ version:'v1.0', generated_at: gen, byTopic }, null, 2);\nconst cPayload = JSON.stringify({ version:'v1.0', generated_at: gen, byCountry }, null, 2);\nconst tContent = Buffer.from(tPayload).toString('base64');\nconst cContent = Buffer.from(cPayload).toString('base64');\nreturn [\n  { json:{ base, branch, path:'data/index/by-topic.json', content: tContent, message:'chore(index): by-topic' } },\n  { json:{ base, branch, path:'data/index/by-country.json', content: cContent, message:'chore(index): by-country' } }\n];"
      },
      "id": "774bce37-4e5e-4261-a530-1e338f3774ad",
      "name": "BUILD_MASTER_INDEX",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1120,
        704
      ]
    },
    {
      "parameters": {
        "url": "={{$json.base}}/{{ $json.path }}?ref={{$json.branch}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            }
          ]
        },
        "options": {
          "timeout": 60000,
          "ignoreResponseCode": true
        }
      },
      "id": "4ae0c33c-dda1-4dd7-842f-603f3328267f",
      "name": "GITHUB_GET_BY_TOPIC_SHA",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -816,
        896
      ],
      "alwaysOutputData": true,
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// BUILD_PUT_GENERIC \u2014 merge meta + sha from both inputs into PUT body\nconst all = $input.all();\nconst meta = all.find(i => i.json && i.json.base && i.json.path);\nif (!meta) return [];\nfunction respOf(it){ const j = it && it.json; if(!j) return {}; if(j.body && typeof j.body==='object') return j.body; if(j.data && typeof j.data==='object') return j.data; return j; }\nconst shaItem = all.find(i => { const r = respOf(i); return r && typeof r.sha === 'string'; });\nconst r = shaItem ? respOf(shaItem) : {};\nconst { base, branch, path, content, message } = meta.json;\nconst body = { message, content, branch };\nif (typeof r.sha === 'string') body.sha = r.sha;\nreturn [{ json: { url: `${base}/${path}`, body } }];\n"
      },
      "id": "38d435f6-ed7d-430f-ac46-cf5782a27b12",
      "name": "BUILD_PUT_BY_TOPIC",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -80,
        848
      ]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "={{$json.url}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.body }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "63b2f1b0-669c-45fe-96a3-e9c4bdddc273",
      "name": "GITHUB_PUT_BY_TOPIC",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        64,
        848
      ],
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      }
    },
    {
      "parameters": {
        "url": "={{$json.base}}/{{ $json.path }}?ref={{$json.branch}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            }
          ]
        },
        "options": {
          "timeout": 60000,
          "ignoreResponseCode": true
        }
      },
      "id": "5ab89c4c-d6b5-42bf-992b-7706be4c0c4f",
      "name": "GITHUB_GET_BY_COUNTRY_SHA",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -832,
        1072
      ],
      "alwaysOutputData": true,
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// BUILD_PUT_GENERIC \u2014 merge meta + sha from both inputs into PUT body\nconst all = $input.all();\nconst meta = all.find(i => i.json && i.json.base && i.json.path);\nif (!meta) return [];\nfunction respOf(it){ const j = it && it.json; if(!j) return {}; if(j.body && typeof j.body==='object') return j.body; if(j.data && typeof j.data==='object') return j.data; return j; }\nconst shaItem = all.find(i => { const r = respOf(i); return r && typeof r.sha === 'string'; });\nconst r = shaItem ? respOf(shaItem) : {};\nconst { base, branch, path, content, message } = meta.json;\nconst body = { message, content, branch };\nif (typeof r.sha === 'string') body.sha = r.sha;\nreturn [{ json: { url: `${base}/${path}`, body } }];\n"
      },
      "id": "ac3a820f-feea-4aa8-9cfa-1b4ea8b9fe8e",
      "name": "BUILD_PUT_BY_COUNTRY",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        16,
        1056
      ]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "={{$json.url}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.body }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "79d9a653-f3b5-4425-868b-a1428537274e",
      "name": "GITHUB_PUT_BY_COUNTRY",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        368,
        976
      ],
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// BUILD_CATALOG \u2014 list available day partitions (seed with today)\nconst today = new Date().toISOString().slice(0,10);\nfunction paramsOf(name){ try{ const it=$items(name,0,0); return it && it.json && it.json.params ? it.json.params : {}; }catch(_){ return {}; } }\nconst p = paramsOf('BUILD_PARAMS');\nconst owner=p.repoOwner||'vulcanoai'; const repo=p.repoName||'vulcanoai.github.io'; const branch=p.branch||'main';\nconst base=`https://api.github.com/repos/${owner}/${repo}/contents`;\nconst payload = JSON.stringify({ version:'v1.0', generated_at:new Date().toISOString(), days:[ today ] }, null, 2);\nconst content = Buffer.from(payload).toString('base64');\nreturn [{ json:{ base, branch, path:'data/index/catalog.json', content, message:'chore(index): catalog' } }];"
      },
      "id": "39d12c90-e100-481d-83b7-03d75b4b3b72",
      "name": "BUILD_CATALOG",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1136,
        1072
      ]
    },
    {
      "parameters": {
        "url": "={{$json.base}}/{{ $json.path }}?ref={{$json.branch}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            }
          ]
        },
        "options": {
          "timeout": 60000,
          "ignoreResponseCode": true
        }
      },
      "id": "a9ec2e8a-6efc-4102-ad13-e119726c8c20",
      "name": "GITHUB_GET_CATALOG_SHA",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -912,
        1296
      ],
      "alwaysOutputData": true,
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// BUILD_PUT_GENERIC \u2014 merge meta + sha from both inputs into PUT body\nconst all = $input.all();\nconst meta = all.find(i => i.json && i.json.base && i.json.path);\nif (!meta) return [];\nfunction respOf(it){ const j = it && it.json; if(!j) return {}; if(j.body && typeof j.body==='object') return j.body; if(j.data && typeof j.data==='object') return j.data; return j; }\nconst shaItem = all.find(i => { const r = respOf(i); return r && typeof r.sha === 'string'; });\nconst r = shaItem ? respOf(shaItem) : {};\nconst { base, branch, path, content, message } = meta.json;\nconst body = { message, content, branch };\nif (typeof r.sha === 'string') body.sha = r.sha;\nreturn [{ json: { url: `${base}/${path}`, body } }];\n"
      },
      "id": "190388af-654f-4dcd-a1c4-1056331677c7",
      "name": "BUILD_PUT_CATALOG",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        16,
        1312
      ]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "={{$json.url}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.body }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "2f666fd5-53a9-4813-bdfa-07f49a09dc65",
      "name": "GITHUB_PUT_CATALOG",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        272,
        1168
      ],
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      }
    },
    {
      "parameters": {
        "mode": "mergeByPosition",
        "options": {}
      },
      "id": "f7e181e0-2859-46df-874c-55df8f839056",
      "name": "BY_TOPIC_SHA_MERGE",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        -416,
        880
      ]
    },
    {
      "parameters": {
        "mode": "mergeByPosition",
        "options": {}
      },
      "id": "8770c726-0b1f-4b52-a6c0-1419c34df087",
      "name": "BY_COUNTRY_SHA_MERGE",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        -240,
        1088
      ]
    },
    {
      "parameters": {
        "mode": "mergeByPosition",
        "options": {}
      },
      "id": "f892393c-1c06-4cdc-ae82-c7c19957f169",
      "name": "CATALOG_SHA_MERGE",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        -368,
        1312
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "INDEX_SHA_MERGE3": {
      "main": [
        [
          {
            "node": "BUILD_PUT_DAILY_INDEX",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AUTOPILOT (hourly)": {
      "main": [
        [
          {
            "node": "START",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BUILD_DAILY_INDEX": {
      "main": [
        [
          {
            "node": "GITHUB_GET_DAILY_INDEX_SHA",
            "type": "main",
            "index": 0
          },
          {
            "node": "INDEX_SHA_MERGE3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GITHUB_GET_DAILY_INDEX_SHA": {
      "main": [
        [
          {
            "node": "INDEX_SHA_MERGE3",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "BUILD_PUT_DAILY_INDEX": {
      "main": [
        [
          {
            "node": "GITHUB_PUT_DAILY_INDEX",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GITHUB_GET_SNAPSHOT_SHA": {
      "main": [
        [
          {
            "node": "BUILD_PUT_SNAPSHOT",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FEED_IN": {
      "main": [
        [
          {
            "node": "START",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "START": {
      "main": [
        [
          {
            "node": "BUILD_PARAMS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BUILD_PARAMS": {
      "main": [
        [
          {
            "node": "AGENT \u2014 Research",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "xAI Grok Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AGENT \u2014 Research",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Aether Memory": {
      "ai_memory": [
        [
          {
            "node": "AGENT \u2014 Research",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "AGENT \u2014 Research": {
      "main": [
        [
          {
            "node": "PARSE_AGENT_JSON (safe)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PARSE_AGENT_JSON (safe)": {
      "main": [
        [
          {
            "node": "VALIDATE_DEDUPE_SORT",
            "type": "main",
            "index": 0
          },
          {
            "node": "DIRECT_NORMALIZE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BUILD_GH_BODY": {
      "main": [
        [
          {
            "node": "GITHUB_GET_LATEST_SHA",
            "type": "main",
            "index": 0
          },
          {
            "node": "GITHUB_GET_SNAPSHOT_SHA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GITHUB_GET_LATEST_SHA": {
      "main": [
        [
          {
            "node": "BUILD_PUT_LATEST",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BUILD_PUT_LATEST": {
      "main": [
        [
          {
            "node": "GITHUB_PUT_LATEST",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GITHUB_PUT_LATEST": {
      "main": [
        [
          {
            "node": "RESPOND (FEED_IN)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BUILD_PUT_SNAPSHOT": {
      "main": [
        [
          {
            "node": "GITHUB_PUT_SNAPSHOT",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BUILD_ENTRY_FILES": {
      "main": [
        [
          {
            "node": "GITHUB_GET_ENTRY_SHA",
            "type": "main",
            "index": 0
          },
          {
            "node": "ENTRY_SHA_MERGE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GITHUB_GET_ENTRY_SHA": {
      "main": [
        [
          {
            "node": "ENTRY_SHA_MERGE",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "ENTRY_SHA_MERGE": {
      "main": [
        [
          {
            "node": "BUILD_PUT_ENTRY",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BUILD_PUT_ENTRY": {
      "main": [
        [
          {
            "node": "GITHUB_PUT_ENTRY",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DIRECT_NORMALIZE": {
      "main": [
        [
          {
            "node": "BUILD_ENTRY_FILES",
            "type": "main",
            "index": 0
          },
          {
            "node": "BUILD_DAILY_INDEX",
            "type": "main",
            "index": 0
          },
          {
            "node": "BUILD_RUN_FILE",
            "type": "main",
            "index": 0
          },
          {
            "node": "BUILD_GH_BODY",
            "type": "main",
            "index": 0
          },
          {
            "node": "BUILD_MASTER_INDEX",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BUILD_RUN_FILE": {
      "main": [
        [
          {
            "node": "GITHUB_PUT_RUN",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GITHUB_GET_BY_TOPIC_SHA": {
      "main": [
        [
          {
            "node": "BY_TOPIC_SHA_MERGE",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "BUILD_PUT_BY_TOPIC": {
      "main": [
        [
          {
            "node": "GITHUB_PUT_BY_TOPIC",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GITHUB_GET_BY_COUNTRY_SHA": {
      "main": [
        [
          {
            "node": "BY_COUNTRY_SHA_MERGE",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "BUILD_PUT_BY_COUNTRY": {
      "main": [
        [
          {
            "node": "GITHUB_PUT_BY_COUNTRY",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BUILD_MASTER_INDEX": {
      "main": [
        [
          {
            "node": "GITHUB_GET_BY_TOPIC_SHA",
            "type": "main",
            "index": 0
          },
          {
            "node": "GITHUB_GET_BY_COUNTRY_SHA",
            "type": "main",
            "index": 0
          },
          {
            "node": "BY_TOPIC_SHA_MERGE",
            "type": "main",
            "index": 0
          },
          {
            "node": "BY_COUNTRY_SHA_MERGE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GITHUB_GET_CATALOG_SHA": {
      "main": [
        [
          {
            "node": "CATALOG_SHA_MERGE",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "BUILD_PUT_CATALOG": {
      "main": [
        [
          {
            "node": "GITHUB_PUT_CATALOG",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BUILD_CATALOG": {
      "main": [
        [
          {
            "node": "GITHUB_GET_CATALOG_SHA",
            "type": "main",
            "index": 0
          },
          {
            "node": "CATALOG_SHA_MERGE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BY_TOPIC_SHA_MERGE": {
      "main": [
        [
          {
            "node": "BUILD_PUT_BY_TOPIC",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BY_COUNTRY_SHA_MERGE": {
      "main": [
        [
          {
            "node": "BUILD_PUT_BY_COUNTRY",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CATALOG_SHA_MERGE": {
      "main": [
        [
          {
            "node": "BUILD_PUT_CATALOG",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "2733ece6-0196-41fd-aa29-370809541185",
  "meta": {
    "instanceId": "99f6164f62c22d699c9ce9932f4b521d20a24970022054dc68b9a0dd16ce6d86"
  },
  "id": "tshQmJwZGsuggmaM",
  "tags": []
}