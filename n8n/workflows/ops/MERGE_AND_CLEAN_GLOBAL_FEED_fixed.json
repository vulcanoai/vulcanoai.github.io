{
  "name": "GLOBAL - Merge & Clean Feed (fixed)",
  "nodes": [
    {
      "parameters": { "rule": { "interval": [ { "field": "hours" } ] } },
      "id": "trg-merge",
      "name": "AUTOPILOT_hourly",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1,
      "position": [ -1960, 60 ]
    },
    {
      "parameters": { "httpMethod": "POST", "path": "merge-clean-feed", "responseMode": "responseNode", "options": { "rawBody": true } },
      "id": "wh-merge",
      "name": "MERGE_IN",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [ -1960, 260 ]
    },
    { "parameters": {}, "id": "start-merge", "name": "START", "type": "n8n-nodes-base.merge", "typeVersion": 2, "position": [ -1780, 160 ] },
    {
      "parameters": {
        "jsCode": "let body=$json.body; if(typeof body==='string'){ try{ body=JSON.parse(body);}catch{ body={}; } } const date=new Date().toISOString().slice(0,10); const params={ owner: body?.repo_owner||'vulcanoai', repo: body?.repo_name||'vulcanoai.github.io', branch: body?.branch||'main', paths: ['data/startups/feed-latest.json','data/ai-research/feed-latest.json','data/discovery/feed-latest.json'], includeExisting: (body?.include_existing===true), outLatest: 'data/feed-latest.json', outSnapshot: `data/feed-${date}.json`, timeWindowHours: Number(body?.time_window_hours ?? 96) }; return [{ json: { params } }];"
      },
      "id": "build-params",
      "name": "BUILD_PARAMS",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [ -1600, 160 ]
    },
    {
      "parameters": { "jsCode": "const params = ($json.params && typeof $json.params==='object')? $json.params : {}; const owner=params.owner||'vulcanoai'; const repo=params.repo||'vulcanoai.github.io'; const branch=params.branch||'main'; let paths = Array.isArray(params.paths)? params.paths.slice() : []; if(!paths.length){ paths = ['data/startups/feed-latest.json']; } const base=`https://api.github.com/repos/${owner}/${repo}/contents`; const out = paths.map(p=>({ json:{ base, branch, path:p } })); if(params.includeExisting){ out.push({ json:{ base, branch, path: (params.outLatest||'data/feed-latest.json') } }); } return out;" },
      "id": "expand-gets",
      "name": "EXPAND_GITHUB_GETS",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [ -1420, 160 ]
    },
    {
      "parameters": {
        "url": "={{$json.base}}/{{ $json.path }}?ref={{$json.branch}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": { "parameters": [ { "name": "Accept", "value": "application/vnd.github+json" } ] }
      },
      "id": "gh-get",
      "name": "GITHUB_GET_CONTENT",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [ -1240, 160 ],
      "alwaysOutputData": true,
      "continueOnFail": true,
      "credentials": { "githubApi": { "id": "fiWvt8LJXl85zjSx", "name": "GitHub account" } }
    },
    {
      "parameters": {
        "jsCode": "const j=$json||{}; const payload = (j.body && typeof j.body==='object')? j.body : (j.data && typeof j.data==='object'? j.data : j); const b64 = payload.content; let articles=[]; if(typeof b64==='string'){ try{ const text=Buffer.from(b64,'base64').toString('utf8'); const obj=JSON.parse(text); const arr = Array.isArray(obj)? obj : (Array.isArray(obj.articles)? obj.articles : []); articles = arr; }catch{} } return [{ json: { articles } }];"
      },
      "id": "parse-cat",
      "name": "PARSE_CATEGORY",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [ -1060, 160 ]
    },
    {
      "parameters": {
        "jsCode": "function p(){ try{ return $items('BUILD_PARAMS',0,0).json.params; }catch{ return {}; } } const params=p(); const now=Date.now(); const hours=params.timeWindowHours||96; const arr=[]; for(const it of $input.all()){ const a=Array.isArray(it.json.articles)? it.json.articles: []; for(const x of a){ if(x && x.url) arr.push(x); } } const seen=new Set(); const dedup=[]; for(const a of arr){ const k=(a.url||'').trim(); if(!k||seen.has(k)) continue; seen.add(k); dedup.push(a); } const filtered = dedup.filter(a=>{ const t=new Date(a.published_at||a.date||a.pubDate||'').getTime(); return !isFinite(t) || (now - t) <= hours*3600*1000; }); filtered.sort((a,b)=> new Date(b.published_at||b.date||0) - new Date(a.published_at||a.date||0)); const items = filtered.map(a=>({ json: a })); if(!items.length) return [{ json: { __empty: true } }]; return items;"
      },
      "id": "expand-articles",
      "name": "EXPAND_ARTICLES",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [ -880, 160 ]
    },
    {
      "parameters": { "method": "GET", "url": "={{$json.url}}", "responseFormat": "string", "options": { "timeout": 12000, "maxRedirects": 5 } },
      "id": "http-validate",
      "name": "HTTP_VALIDATE",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [ -700, 160 ],
      "alwaysOutputData": true,
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "const u = (($json.url||'')+ '').trim(); if(!u || !/^https?:\\/\\//i.test(u)) return []; return [{ json: $json }];"
      },
      "id": "filter-has-url",
      "name": "FILTER_HAS_URL",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [ -780, 60 ]
    },
    {
      "parameters": {
        "jsCode": "return [{ json: { orig: $json } }];"
      },
      "id": "keep-orig",
      "name": "KEEP_ORIG",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [ -700, -40 ]
    },
    {
      "parameters": {
        "mode": "combine"
      },
      "id": "merge-validate",
      "name": "MERGE_VALIDATE",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [ -520, 60 ]
    },
    {
      "parameters": {
        "jsCode": "const status = Number($json.statusCode||$json.status||0); if(!(status>=200 && status<400)) return []; const a = ($json.orig||{}); if(!a.url) return []; const out = { id: a.url||a.id, title: a.title||'', summary: a.summary||'', url: a.url||'', source: a.source||'', source_url: a.source_url || (a.url? new URL(a.url).origin: ''), country: a.country||'Regional', topics: Array.isArray(a.topics)? a.topics : ['AI'], language: (a.language||'en').slice(0,2), published_at: a.published_at || new Date().toISOString(), relevance: a.relevance||5, sentiment: a.sentiment||'neutral', author: a.author||'', curator: a.curator||'Luciano AI' }; return [{ json: out }];"
      },
      "id": "filter-valid",
      "name": "FILTER_VALID",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [ -520, 160 ]
    },
    {
      "parameters": {
        "jsCode": "if($json.__empty) return [{ json: { articles: [] } }]; return [];"
      },
      "id": "if-empty",
      "name": "IF_EMPTY_TO_COLLAPSE",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [ -700, 260 ]
    },
    {
      "parameters": {
        "jsCode": "const all=$input.all(); const seen=new Set(); const out=[]; for(const it of all){ const a=it.json; if(!a||!a.url) continue; const u=a.url.trim(); if(seen.has(u)) continue; seen.add(u); out.push(a); } out.sort((a,b)=> new Date(b.published_at)-new Date(a.published_at)); return [{ json: { articles: out } }];"
      },
      "id": "collapse",
      "name": "COLLAPSE",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [ -340, 160 ]
    },
    {
      "parameters": {
        "jsCode": "// PUBLISH_GATE — require minimum items and distinct sources\nfunction distinctSources(arr){ const s=new Set(); for(const a of arr){ const v=(a.source||'').toString().trim(); if(v) s.add(v); } return s.size; }\nconst arts = Array.isArray($json.articles) ? $json.articles : [];\nlet minItems = 5; let minSources = 3;\ntry{ const p = $items('BUILD_PARAMS',0,0)?.json?.params || {}; minItems = Number(p.minItemsGate||5)||5; minSources = Number(p.minSourcesGate||3)||3; }catch(_){}\nif (arts.length >= minItems && distinctSources(arts) >= minSources){ return [{ json: { articles: arts } }]; } else { return []; }"
      },
      "id": "publish-gate",
      "name": "PUBLISH_GATE",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [ -256, 256 ]
    },
    {
      "parameters": {
        "jsCode": "// BUILD_STATUS — telemetry summary based on collapsed articles\nfunction p(){ try{ return $items('BUILD_PARAMS',0,0).json.params; }catch{ return {}; } } const params=p(); const arts=Array.isArray($json.articles)? $json.articles: []; const sources=new Set(); for(const a of arts){ if(a&&a.source) sources.add(String(a.source).trim()); } const payload={ version:'v1.0', generated_at:new Date().toISOString(), feed_count: arts.length, sources_count: sources.size, time_window_hours: params.timeWindowHours||null, include_existing: params.includeExisting===true, last_run_iso: new Date().toISOString() }; const content=Buffer.from(JSON.stringify(payload,null,2)).toString('base64'); const owner=params.owner||'vulcanoai'; const repo=params.repo||'vulcanoai.github.io'; const branch=params.branch||'main'; const base=`https://api.github.com/repos/${owner}/${repo}/contents`; return [{ json:{ base, branch, path:'data/index/status.json', content, message:'chore(status): update feed status' } }];"
      },
      "id": "build-status",
      "name": "BUILD_STATUS",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [ -160, 64 ]
    },
    { "parameters": { "url": "={{$json.base}}/{{ $json.path }}?ref={{$json.branch}}", "authentication": "predefinedCredentialType", "nodeCredentialType": "githubApi", "sendHeaders": true, "headerParameters": { "parameters": [ { "name": "Accept", "value": "application/vnd.github+json" } ] }, "options": { "timeout": 30000 } }, "id": "gh-get-status-sha", "name": "GITHUB_GET_STATUS_SHA", "type": "n8n-nodes-base.httpRequest", "typeVersion": 4, "position": [ 20, 24 ], "alwaysOutputData": true, "continueOnFail": true, "credentials": { "githubApi": { "id": "fiWvt8LJXl85zjSx", "name": "GitHub account" } } },
    { "parameters": { "jsCode": "const meta=$json||{}; const respRaw=$items('GITHUB_GET_STATUS_SHA',0,0)?.json||{}; const resp=(respRaw.body&&typeof respRaw.body==='object')?respRaw.body:((respRaw.data&&typeof respRaw.data==='object')?respRaw.data:respRaw); const body={ message: meta.message||'update', content: meta.content, branch: meta.branch||'main' }; if(resp&&resp.sha) body.sha=resp.sha; return [{ json: { url: `${meta.base}/${meta.path}`, body } }];" }, "id": "build-put-status", "name": "BUILD_PUT_STATUS", "type": "n8n-nodes-base.code", "typeVersion": 2, "position": [ 200, 24 ] },
    { "parameters": { "method": "PUT", "url": "={{$json.url}}", "authentication": "predefinedCredentialType", "nodeCredentialType": "githubApi", "sendHeaders": true, "headerParameters": { "parameters": [ { "name": "Accept", "value": "application/vnd.github+json" }, { "name": "Content-Type", "value": "application/json" } ] }, "sendBody": true, "specifyBody": "json", "jsonBody": "={{ $json.body }}", "options": { "timeout": 60000 } }, "id": "gh-put-status", "name": "GITHUB_PUT_STATUS", "type": "n8n-nodes-base.httpRequest", "typeVersion": 4, "position": [ 380, 24 ], "credentials": { "githubApi": { "id": "fiWvt8LJXl85zjSx", "name": "GitHub account" } } },
    {
      "parameters": {
        "jsCode": "function p(){ try{ return $items('BUILD_PARAMS',0,0).json.params; }catch{ return {}; } } const params=p(); const owner=params.owner||'vulcanoai'; const repo=params.repo||'vulcanoai.github.io'; const branch=params.branch||'main'; const base=`https://api.github.com/repos/${owner}/${repo}/contents`; const latestPath=params.outLatest||'data/feed-latest.json'; const payload = { version:'v1.0', generated_at: new Date().toISOString(), articles: ($json.articles||[]) }; const content=Buffer.from(JSON.stringify(payload,null,2)).toString('base64'); return [ { json: { base, branch, path: latestPath, content, message: 'chore(feed): clean+merge latest' } } ];"
      },
      "id": "build-gh",
      "name": "BUILD_GH_BODY",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [ -160, 160 ]
    },
    { "parameters": { "url": "={{$json.base}}/{{ $json.path }}?ref={{$json.branch}}", "authentication": "predefinedCredentialType", "nodeCredentialType": "githubApi", "sendHeaders": true, "headerParameters": { "parameters": [ { "name": "Accept", "value": "application/vnd.github+json" } ] } }, "id": "gh-get-sha", "name": "GITHUB_GET_SHA", "type": "n8n-nodes-base.httpRequest", "typeVersion": 4, "position": [ 20, 80 ], "alwaysOutputData": true, "continueOnFail": true, "credentials": { "githubApi": { "id": "fiWvt8LJXl85zjSx", "name": "GitHub account" } } },
    {
      "parameters": {
        "mode": "append"
      },
      "id": "merge-meta-sha",
      "name": "MERGE_META_SHA",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [ 200, 160 ]
    },
    {
      "parameters": {
        "jsCode": "const all=$input.all(); function respOf(it){ const j=(it&&it.json)||{}; if(j.body&&typeof j.body==='object') return j.body; if(j.data&&typeof j.data==='object') return j.data; return j; } const metaItem=all.find(it=>it.json&&it.json.base&&it.json.path); const meta=(metaItem&&metaItem.json)||{}; const shaItem=all.find(it=>{ const r=respOf(it); return r && typeof r.sha==='string'; }); const resp=respOf(shaItem); const base=meta.base||''; const path=meta.path||''; const branch=meta.branch||'main'; const message=meta.message||'update'; const content=meta.content; const body={ message, content, branch }; if(resp && typeof resp.sha==='string') body.sha=resp.sha; return [{ json:{ url: `${base}/${path}`, body } }];"
      },
      "id": "build-put",
      "name": "BUILD_PUT",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [ 380, 160 ]
    },
    { "parameters": { "method": "PUT", "url": "={{$json.url}}", "authentication": "predefinedCredentialType", "nodeCredentialType": "githubApi", "sendHeaders": true, "headerParameters": { "parameters": [ { "name": "Accept", "value": "application/vnd.github+json" }, { "name": "Content-Type", "value": "application/json" } ] }, "sendBody": true, "specifyBody": "json", "jsonBody": "={{ $json.body }}", "options": { "timeout": 60000 } }, "id": "gh-put", "name": "GITHUB_PUT", "type": "n8n-nodes-base.httpRequest", "typeVersion": 4, "position": [ 540, 160 ], "credentials": { "githubApi": { "id": "fiWvt8LJXl85zjSx", "name": "GitHub account" } } },
    { "parameters": { "options": { "responseCode": 200 } }, "id": "respond", "name": "RESPOND", "type": "n8n-nodes-base.respondToWebhook", "typeVersion": 1, "position": [ 720, 160 ] }
  ],
  "connections": {
    "AUTOPILOT_hourly": { "main": [ [ { "node": "START", "type": "main", "index": 0 } ] ] },
    "MERGE_IN": { "main": [ [ { "node": "START", "type": "main", "index": 0 } ] ] },
    "START": { "main": [ [ { "node": "BUILD_PARAMS", "type": "main", "index": 0 } ] ] },
    "BUILD_PARAMS": { "main": [ [ { "node": "EXPAND_GITHUB_GETS", "type": "main", "index": 0 } ] ] },
    "EXPAND_GITHUB_GETS": { "main": [ [ { "node": "GITHUB_GET_CONTENT", "type": "main", "index": 0 } ] ] },
    "GITHUB_GET_CONTENT": { "main": [ [ { "node": "PARSE_CATEGORY", "type": "main", "index": 0 } ] ] },
    "PARSE_CATEGORY": { "main": [ [ { "node": "EXPAND_ARTICLES", "type": "main", "index": 0 } ] ] },
    "EXPAND_ARTICLES": { "main": [ [ { "node": "FILTER_HAS_URL", "type": "main", "index": 0 }, { "node": "IF_EMPTY_TO_COLLAPSE", "type": "main", "index": 0 } ] ] },
    "FILTER_HAS_URL": { "main": [ [ { "node": "HTTP_VALIDATE", "type": "main", "index": 0 }, { "node": "KEEP_ORIG", "type": "main", "index": 0 } ] ] },
    "HTTP_VALIDATE": { "main": [ [ { "node": "MERGE_VALIDATE", "type": "main", "index": 0 } ] ] },
    "KEEP_ORIG": { "main": [ [ { "node": "MERGE_VALIDATE", "type": "main", "index": 1 } ] ] },
    "MERGE_VALIDATE": { "main": [ [ { "node": "FILTER_VALID", "type": "main", "index": 0 } ] ] },
    "IF_EMPTY_TO_COLLAPSE": { "main": [ [ { "node": "COLLAPSE", "type": "main", "index": 0 } ] ] },
    "FILTER_VALID": { "main": [ [ { "node": "FILTER_QA", "type": "main", "index": 0 } ] ] },
    "FILTER_QA": { "main": [ [ { "node": "COLLAPSE", "type": "main", "index": 0 } ] ] },
    "COLLAPSE": { "main": [ [ { "node": "PUBLISH_GATE", "type": "main", "index": 0 }, { "node": "BUILD_STATUS", "type": "main", "index": 0 } ] ] },
    "PUBLISH_GATE": { "main": [ [ { "node": "BUILD_GH_BODY", "type": "main", "index": 0 } ] ] },
    "BUILD_GH_BODY": { "main": [ [ { "node": "GITHUB_GET_SHA", "type": "main", "index": 0 }, { "node": "MERGE_META_SHA", "type": "main", "index": 0 } ] ] },
    "GITHUB_GET_SHA": { "main": [ [ { "node": "MERGE_META_SHA", "type": "main", "index": 1 } ] ] },
    "MERGE_META_SHA": { "main": [ [ { "node": "BUILD_PUT", "type": "main", "index": 0 } ] ] },
    "BUILD_PUT": { "main": [ [ { "node": "GITHUB_PUT", "type": "main", "index": 0 } ] ] },
    "GITHUB_PUT": { "main": [ [ { "node": "RESPOND", "type": "main", "index": 0 } ] ] }
  },
  "active": false,
  "settings": { "executionOrder": "v1", "callerPolicy": "workflowsFromSameOwner" },
  "pinData": {},
  "versionId": "v1-merge-clean-fixed",
  "id": "wk-merge-clean-feed-fixed",
  "tags": ["merge","clean","global","feed"]
}
