{
  "name": "PRODUCTION — Feed News Autopilot",
  "nodes": [
    {
      "parameters": {
        "mode": "mergeByPosition",
        "options": {}
      },
      "id": "644965bb-7550-4fca-bc8e-0dba3776c20c",
      "name": "INDEX_SHA_MERGE3",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        -704,
        592
      ]
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours"
            }
          ]
        }
      },
      "id": "5c77f89a-1212-430f-945d-9c28dee8a34d",
      "name": "AUTOPILOT (hourly)",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1,
      "position": [
        -2544,
        272
      ],
      "notes": "Runs every hour. You can change to 30min or daily."
    },
    {
      "parameters": {
        "jsCode": "// BUILD_DAILY_INDEX — build per-day index of entries; skip if no articles\nconst articles = Array.isArray($json.articles) ? $json.articles : [];\nif (!articles.length) return [];\nconst dateStr = (new Date().toISOString()).slice(0,10);\n// Lightweight index with summaries for navigation\nconst byTopic = {};\nconst byCountry = {};\nfor (const a of articles){\n  for (const t of (a.topics||[])){ byTopic[t] = (byTopic[t]||0) + 1; }\n  const c = a.country || 'Regional'; byCountry[c] = (byCountry[c]||0) + 1;\n}\nconst index = { version: 'v1.0', date: dateStr, count: articles.length, topics: byTopic, countries: byCountry, generated_at: new Date().toISOString() };\nconst payload = JSON.stringify(index, null, 2);\nconst content = Buffer.from(payload).toString('base64');\n// We derive base from BUILD_PARAMS for owner/repo/branch (use $items, not $(...))\nfunction item(n){ try{ const it=$items(n,0,0); return it && it.json ? it.json : null; }catch(_){ return null; } }\nconst pItem = item('BUILD_PARAMS') || {};\nconst params = (pItem.params) || {};\nconst owner = params.repoOwner || 'vulcanoai';\nconst repo  = params.repoName  || 'vulcanoai.github.io';\nconst branch= params.branch     || 'main';\nconst base  = `https://api.github.com/repos/${owner}/${repo}/contents`;\nconst path = `data/entries/${dateStr}/index.json`;\nconst message = `chore(index): daily entries index ${dateStr}`;\nreturn [ { json: { base, branch, path, content, payload, message } } ];"
      },
      "id": "28148c9f-3cfb-4094-a8ac-5a2e05df5fc8",
      "name": "BUILD_DAILY_INDEX",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1136,
        496
      ]
    },
    {
      "parameters": {
        "url": "={{$json.base}}/{{ $json.path }}?ref={{$json.branch}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            }
          ]
        },
        "options": {
          "timeout": 60000
        }
      },
      "id": "e12c1bac-3605-45f0-9be2-1188a54b4599",
      "name": "GITHUB_GET_DAILY_INDEX_SHA",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -912,
        496
      ],
      "alwaysOutputData": true,
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// BUILD_PUT_DAILY_INDEX — merge meta + sha from both inputs into PUT body\nconst all = $input.all();\nconst meta = all.find(i => i.json && i.json.base && i.json.path);\nconst resp = all.find(i => i.json && (i.json.sha || (i.json.body && i.json.body.sha) || (i.json.data && i.json.data.sha)));\nif (!meta) return [];\nconst { base, branch, path, content, message } = meta.json;\nlet sha = resp ? (resp.json.sha || (resp.json.body && resp.json.body.sha) || (resp.json.data && resp.json.data.sha)) : undefined;\nconst body = { message, content, branch };\nif (sha) body.sha = sha;\nreturn [{ json: { url: `${base}/${path}`, body } }];\n"
      },
      "id": "8b03e94f-ec8a-4bb8-a2ac-9eb1b9e3c4a7",
      "name": "BUILD_PUT_DAILY_INDEX",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -528,
        560
      ]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.url }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.body }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "6e8b1d69-7e52-4153-b776-49904baf96d7",
      "name": "GITHUB_PUT_DAILY_INDEX",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -320,
        672
      ],
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      }
    },
    {
      "parameters": {
        "url": "={{$json.base}}/{{ $json.pathSnapshot }}?ref={{$json.branch}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            }
          ]
        },
        "options": {
          "timeout": 60000
        }
      },
      "id": "148f0b42-04ce-42bb-9763-5a8f3b67acab",
      "name": "GITHUB_GET_SNAPSHOT_SHA",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -944,
        -208
      ],
      "alwaysOutputData": true,
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      },
      "continueOnFail": true,
      "notes": "Read snapshot file to get sha if it exists."
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "f0c79f59-c04c-4052-8683-950101645999",
        "responseMode": "responseNode",
        "options": {
          "rawBody": true
        }
      },
      "id": "79f2c09b-710b-4524-9948-c4a4a5783f4a",
      "name": "FEED_IN",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -2544,
        480
      ],
      "webhookId": "f0c79f59-c04c-4052-8683-950101645999",
      "notes": "Webhook to trigger on-demand runs with custom prompt/params."
    },
    {
      "parameters": {},
      "id": "ee2a3d70-0b2c-4f97-a460-52bd7e1cf909",
      "name": "START",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        -2320,
        368
      ],
      "notes": "Merge schedule + webhook into a single flow"
    },
    {
      "parameters": {
        "jsCode": "// BUILD_PARAMS: parse webhook body or defaults for autopilot\nconst isWebhook = !!$json.headers;\nlet src = $json.body || $json || {};\nif (typeof src === 'string') { try { src = JSON.parse(src); } catch { src = {}; } }\nif (!src || typeof src !== 'object') src = {};\n\n// Query defaults (tunable)\nconst q = src.prompt || src.query || 'artificial intelligence OR inteligencia artificial OR IA latinoamérica OR latin america (last 24 hours)';\nconst timeWindowHours = Number(src.time_window_hours ?? 24);\nconst languages = Array.isArray(src.languages) ? src.languages : ['es','pt'];\nconst minSources = Number(src.min_sources ?? 1);\n\n// Publication settings (no secrets here; set in n8n secrets)\nconst repoOwner = src.repo_owner || 'vulcanoai';\nconst repoName  = src.repo_name  || 'vulcanoai.github.io';\nconst branch    = src.branch     || 'main';\nconst pathLatest   = src.path_latest   || 'data/feed-latest.json';\nconst pathSnapshot = src.path_snapshot || `data/feed-${new Date().toISOString().slice(0,10)}.json`;\n\n// Country/topic rules (lightweight heuristics)\nconst countryKeywords = { 'México': ['méxico','cdmx','guadalajara','monterrey'], 'Colombia': ['colombia','bogotá','medellín','cali'], 'Brasil': ['brasil','brazil','são paulo','rio de janeiro'], 'Argentina': ['argentina','buenos aires','córdoba'], 'Chile': ['chile','santiago','valparaíso'], 'Perú': ['perú','lima'], 'Uruguay': ['uruguay','montevideo'], 'Ecuador': ['ecuador','quito','guayaquil'], 'Panamá': ['panamá','ciudad de panamá'], 'Venezuela': ['venezuela','caracas'], 'Paraguay': ['paraguay','asunción'], 'Bolivia': ['bolivia','la paz','santa cruz'], 'Costa Rica': ['costa rica','san josé'], 'República Dominicana': ['república dominicana','santo domingo'] };\nconst topicKeywords = { 'Startups': ['startup','emprendimiento','seed','series a','ronda'], 'Inversión': ['inversión','funding','capital','vc'], 'Regulación': ['regulación','ley','marco','norma','política'], 'Investigación': ['investigación','universidad','estudio','paper'], 'Empresas': ['empresa','corporativo','alianza','lanzamiento'], 'Gobierno': ['gobierno','ministerio','agencia','política pública'], 'Educación': ['educación','beca','curso','programa'], 'Salud': ['salud','hospital','médica','diagnóstico'] };\nconst sentimentIndicators = { positive: ['éxito','crecimiento','innovación','logro','expansión'], negative: ['crisis','problema','falla','recorte','fraude'], neutral:  ['anuncia','presenta','informa','publica'] };\n\nconst feedMaxLatest = Number(src.feed_max_latest ?? 200);\nconst feedMaxSnapshot = Number(src.feed_max_snapshot ?? 500);\nreturn [{ json: { params: { q, timeWindowHours, languages, minSources, repoOwner, repoName, branch, pathLatest, pathSnapshot, feedMaxLatest, feedMaxSnapshot, countryKeywords, topicKeywords, sentimentIndicators } } }];\n"
      },
      "id": "132563ba-ca1c-4c79-91f8-79847afaf714",
      "name": "BUILD_PARAMS",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2112,
        112
      ]
    },
    {
      "parameters": {
        "model": "grok-3-fast",
        "options": {}
      },
      "id": "e6afe91b-7f70-406b-b825-458e47e48208",
      "name": "xAI Grok Chat Model",
      "type": "@n8n/n8n-nodes-langchain.lmChatXAiGrok",
      "typeVersion": 1,
      "position": [
        -1936,
        432
      ],
      "credentials": {
        "xAiApi": {
          "id": "H0GQCuRkHVUlEFKY",
          "name": "xAi account"
        }
      }
    },
    {
      "parameters": {
        "sessionKey": "latam-news"
      },
      "id": "92df6ebc-2cb9-4b43-84f6-bcfd6240c734",
      "name": "Aether Memory",
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1,
      "position": [
        -1840,
        528
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "Eres un agente de investigación periodística para IA en LATAM.\nObjetivo: encontrar noticias verificables de las últimas {{ $items('BUILD_PARAMS',0,0).json.params.timeWindowHours }} horas. Devuelve SOLO JSON estricto.\nEsquema:\n{\n  \"articles\": [\n    {\n      \"title\": \"...\",\n      \"summary\": \"...\",\n      \"url\": \"https://...\",\n      \"source\": \"medio o sitio\",\n      \"source_url\": \"https://...\",\n      \"country\": \"México|Colombia|Regional|...\",\n      \"topics\": [\"Startups\",\"Regulación\",...],\n      \"language\": \"es|pt\",\n      \"published_at\": \"ISO-8601\",\n      \"relevance\": 0-10,\n      \"sentiment\": \"positive|neutral|negative\",\n      \"author\": \"...\",\n      \"curator\": \"Luciano AI\"\n    }\n  ]\n}\nCriterios obligatorios:\n- Solo dominios permitidos (allowlist) definidos en data/sources.json del repositorio.\n- Solo enlaces que resuelven (HTTP 2xx/3xx).\n- Solo artículos dentro del rango ({{ $items('BUILD_PARAMS',0,0).json.params.timeWindowHours }} horas), en español o portugués.\n- No inventes datos. Incluye URL pública exacta.\n- Evita duplicados del mismo medio y misma historia (mismo titular/tema) — conserva la versión más reciente.\nResponde en español con el JSON estricto.",
        "options": {}
      },
      "id": "7e4df115-8550-4b62-878d-b6df759a6507",
      "name": "AGENT — Research",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        -1936,
        112
      ]
    },
    {
      "parameters": {
        "jsCode": "// Parse strict/loose JSON from agent without regex escapes\nconst raw = $json.text ?? $json.output ?? $json;\nconst s = typeof raw==='string' ? raw : JSON.stringify(raw);\nconst i = s.indexOf('{');\nconst j = s.lastIndexOf('}');\nif (i < 0 || j <= i) throw new Error('Agent did not return JSON');\nlet obj;\ntry { obj = JSON.parse(s.slice(i, j+1)); } catch(e){ throw new Error('Invalid JSON from agent'); }\nif(!obj || !Array.isArray(obj.articles)) obj = { articles: [] };\nreturn [{ json: obj }];"
      },
      "id": "580ff0e7-d995-41e5-976b-2d046d35ed97",
      "name": "PARSE_AGENT_JSON (safe)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1520,
        112
      ]
    },
    {
      "parameters": {
        "jsCode": "// Validate + normalize + dedupe + recency filter (robust)\n// 1) Read params safely\nlet params;\ntry { const pA = $items('BUILD_PARAMS', 0, 0); if (pA && pA.json && pA.json.params) { params = pA.json.params; } } catch {}\nif (!params) { try { const pB = $items('BUILD_PARAMS1', 0, 0); if (pB && pB.json && pB.json.params) { params = pB.json.params; } } catch {} }\nif (!params) { params = $json.params || {}; }\n// Defaults\nparams.repoOwner = params.repoOwner || 'vulcanoai';\nparams.repoName  = params.repoName  || 'vulcanoai.github.io';\nparams.branch    = params.branch    || 'main';\nparams.pathLatest   = params.pathLatest   || 'data/feed-latest.json';\nparams.pathSnapshot = params.pathSnapshot || `data/feed-${new Date().toISOString().slice(0,10)}.json`;\nparams.timeWindowHours   = Number(params.timeWindowHours ?? 24);\nparams.maxBackfillHours  = Number(params.maxBackfillHours ?? 336); // ~14 days\nparams.minItems          = Number(params.minItems ?? 1);\nparams.backfillIfEmpty   = params.backfillIfEmpty !== false;\nparams.languages = Array.isArray(params.languages) ? params.languages : ['es','pt'];\n\n// 2) Helpers\nconst allowLangs = new Set((params.languages||[]).map(l=>String(l).slice(0,2).toLowerCase()));\nconst now = Date.now();\nfunction withinHours(ts, hours){ const t=new Date(ts).getTime(); return isFinite(t) && (now - t) <= hours*3600*1000; }\nfunction dedupe(items){ const seen=new Set(); const out=[]; for(const it of items){ const key=it.url||it.id; if(!key||seen.has(key)) continue; seen.add(key); out.push(it); } return out; }\nfunction normalize(a){\n  const title = a.title || a.titulo || '';\n  const url = a.url || a.link || '';\n  let lang = (a.language || a.idioma || '').toString().slice(0,2).toLowerCase();\n  if(!lang) lang = 'es';\n  let pub = a.published_at || a.fecha || new Date().toISOString();\n  const d = new Date(pub);\n  if(!isFinite(d.getTime())) pub = new Date().toISOString();\n  const topics = Array.isArray(a.topics) ? a.topics : (Array.isArray(a.temas) ? a.temas : []);\n  return {\n    id: a.id || url || title,\n    title, url,\n    summary: a.summary || a.resumen || '',\n    source: a.source || a.fuente || '',\n    source_url: a.source_url || a.fuente_url || '',\n    country: a.country || a.pais || 'Regional',\n    topics,\n    language: lang,\n    published_at: pub,\n    relevance: a.relevance || a.relevancia || 0,\n    sentiment: a.sentiment || a.sentimiento || 'neutral',\n    author: a.author || a.autor || '',\n    curator: a.curator || a.curador || 'Luciano AI'\n  };\n}\nfunction filterWindow(items, hours){\n  const arr = [];\n  for (const it of items){\n    if (!it || !it.url || !it.title) continue;\n    if (!withinHours(it.published_at, hours)) continue;\n    const lang = (it.language||'').toString().slice(0,2).toLowerCase();\n    if (allowLangs.size && lang && !allowLangs.has(lang)) continue;\n    arr.push(it);\n  }\n  return arr;\n}\n\n// 3) Process\nconst baseRaw = Array.isArray($json.articles) ? $json.articles : [];\nconst normalized = baseRaw.map(normalize).filter(x=>x && x.url && x.title);\nconst base = dedupe(normalized);\nlet windowH = params.timeWindowHours;\nlet out = filterWindow(base, windowH);\nlet usedBackfill = false;\nif (out.length < params.minItems && params.backfillIfEmpty){\n  let h = Math.min(params.maxBackfillHours, Math.max(windowH*2, 48));\n  while (h <= params.maxBackfillHours && out.length < params.minItems){\n    out = filterWindow(base, h);\n    if (out.length >= params.minItems){ windowH = h; usedBackfill = true; break; }\n    if (h === params.maxBackfillHours) break;\n    h = Math.min(params.maxBackfillHours, h*2);\n  }\n}\n\n// 4) Sort, cap, return\nout.sort((a,b)=> new Date(b.published_at) - new Date(a.published_at) || (b.relevance||0)-(a.relevance||0));\nout.splice(48);\nreturn [{ json: { articles: out, count: out.length, timestamp: new Date().toISOString(), params: { ...params, appliedWindowHours: windowH, usedBackfill } } }];"
      },
      "id": "ce29d8a2-184f-4880-a214-e2e0bed3fd4a",
      "name": "VALIDATE_DEDUPE_SORT",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1328,
        112
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare GitHub upload body (base64) and URLs; skip if no articles\nfunction getNodeItemSafe(name){ try { const it = $items(name, 0, 0); if (it && it.json && !(it.json && it.json.name==='Error')) return it; } catch(e) { return null; } return null; }\nconst pA = getNodeItemSafe('BUILD_PARAMS');\nconst pB = getNodeItemSafe('BUILD_PARAMS1');\nlet params = (pA && pA.json && pA.json.params) || (pB && pB.json && pB.json.params) || $json.params || {};\n// Defaults\nparams.repoOwner = params.repoOwner || 'vulcanoai';\nparams.repoName  = params.repoName  || 'vulcanoai.github.io';\nparams.branch    = params.branch    || 'main';\nparams.pathLatest   = params.pathLatest   || 'data/feed-latest.json';\nparams.pathSnapshot = params.pathSnapshot || `data/feed-${new Date().toISOString().slice(0,10)}.json`;\nconst { repoOwner, repoName, branch, pathLatest, pathSnapshot } = params;\nconst items = Array.isArray($json.articles) ? $json.articles : [];\nif (!items.length) return [];\nconst payload = JSON.stringify({ version: 'v1.0', articles: items }, null, 2);\nconst content = Buffer.from(payload).toString('base64');\nconst base = `https://api.github.com/repos/${repoOwner}/${repoName}/contents`;\nreturn [{ json: { base, branch, pathLatest, pathSnapshot, content, payload, message: `chore(feed): update ${pathLatest} (${new Date().toISOString()})` } }];"
      },
      "id": "53013ad9-3f8e-403d-9ab0-06c156a4576e",
      "name": "BUILD_GH_BODY",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1120,
        176
      ]
    },
    {
      "parameters": {
        "url": "={{$json.base}}/{{ $json.pathLatest }}?ref={{$json.branch}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            }
          ]
        },
        "options": {
          "timeout": 60000
        }
      },
      "id": "876eee74-bc67-4964-ae87-ae9e9f35ca7a",
      "name": "GITHUB_GET_LATEST_SHA",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -960,
        128
      ],
      "alwaysOutputData": true,
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      },
      "continueOnFail": true,
      "notes": "Read current file to get sha (update vs create)."
    },
    {
      "parameters": {
        "jsCode": "function item(n){ try{ const it=$items(n,0,0); return it && it.json ? it.json : null; }catch(_){ return null; } }\nconst ghBody = item('BUILD_GH_BODY') || {};\nconst pItem = item('BUILD_PARAMS') || item('BUILD_PARAMS1');\nconst params = (pItem && pItem.params) || ($json.params || {});\n\n// From immediate upstream (GITHUB_GET_LATEST_SHA)\nconst resp = ($json && typeof $json === 'object')\n  ? ($json.body && typeof $json.body === 'object' ? $json.body\n     : ($json.data && typeof $json.data === 'object' ? $json.data : $json))\n  : {};\nconst sha = typeof resp.sha === 'string' ? resp.sha : undefined;\nconst existingContentB64 = typeof resp.content === 'string' ? resp.content : undefined;\n\nfunction decodeContent(b64){ try{ const j=JSON.parse(Buffer.from(b64, 'base64').toString('utf8')); return Array.isArray(j)? j : (j && j.articles) ? j.articles : []; }catch(_){ return []; } }\n// Defaults\nconst owner = params.repoOwner || 'vulcanoai';\nconst repo = params.repoName || 'vulcanoai.github.io';\nconst branch= ghBody.branch || params.branch || 'main';\nconst pathLatest = ghBody.pathLatest || params.pathLatest || 'data/feed-latest.json';\nconst base = ghBody.base || ('https://api.github.com/repos/' + owner + '/' + repo + '/contents');\n\n// New items from ghBody.content (base64-encoded array)\nconst newItems = (()=>{ try{ const j=JSON.parse(Buffer.from(ghBody.content||'', 'base64').toString('utf8')); return Array.isArray(j)? j : (j && j.articles)? j.articles : []; }catch(_){ return []; }})();\n// Existing items from GET (if file exists)\nconst oldItems = existingContentB64 ? decodeContent(existingContentB64) : [];\n\nif (!Array.isArray(oldItems) || oldItems.length===0) { /* ok */ }\nif (!Array.isArray(newItems) || newItems.length===0) { /* ok */ }\nif ((oldItems?.length||0)===0 && (newItems?.length||0)===0) { return []; }\n// Union by URL (preserve prior, add new uniques)\nconst seen=new Set();\nconst merged=[];\nfor(const it of oldItems){ if(it && it.url && !seen.has(it.url)){ seen.add(it.url); merged.push(it); } }\nfor(const it of newItems){ if(it && it.url && !seen.has(it.url)){ seen.add(it.url); merged.push(it); } }\n// Sort newest first, cap 200\nmerged.sort((a,b)=> new Date(b.published_at)-new Date(a.published_at) || (b.relevance||0)-(a.relevance||0));\nconst cap = Number((item('BUILD_PARAMS')||{}).params?.feedMaxLatest||200);\nmerged.splice(cap);\nconst content = Buffer.from(JSON.stringify({ version:'v1.0', articles: merged }, null, 2)).toString('base64');\nconst message = ghBody.message || ('chore(feed): update ' + pathLatest + ' (' + new Date().toISOString() + ')');\nconst body = { message, content, branch };\nif (sha) body.sha = sha;\nreturn [{ json: { url: base + '/' + pathLatest, body: body } }];\n"
      },
      "id": "742316d2-a349-42b1-b163-510ff0de8cef",
      "name": "BUILD_PUT_LATEST",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -352,
        -64
      ]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "={{$json.url}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.body }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "4f06ca84-5f35-4e49-9ce4-0eff63499a29",
      "name": "GITHUB_PUT_LATEST",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -176,
        -96
      ],
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      },
      "notes": "Writes/updates data/feed-latest.json in repo."
    },
    {
      "parameters": {
        "jsCode": "function item(n){ try{ const it=$items(n,0,0); return it && it.json ? it.json : null; }catch(_){ return null; } }\nconst ghBody = item('BUILD_GH_BODY') || {};\nconst pItem = item('BUILD_PARAMS') || item('BUILD_PARAMS1');\nconst params = (pItem && pItem.params) || ($json.params || {});\n\n// From immediate upstream (GITHUB_GET_SNAPSHOT_SHA)\nconst resp = ($json && typeof $json === 'object')\n  ? ($json.body && typeof $json.body === 'object' ? $json.body\n     : ($json.data && typeof $json.data === 'object' ? $json.data : $json))\n  : {};\nconst sha = typeof resp.sha === 'string' ? resp.sha : undefined;\nconst existingContentB64 = typeof resp.content === 'string' ? resp.content : undefined;\n\nfunction decodeContent(b64){ try{ const j=JSON.parse(Buffer.from(b64, 'base64').toString('utf8')); return Array.isArray(j)? j : (j && j.articles) ? j.articles : []; }catch(_){ return []; } }\nconst owner = params.repoOwner || 'vulcanoai';\nconst repo = params.repoName || 'vulcanoai.github.io';\nconst branch= ghBody.branch || params.branch || 'main';\nconst pathSnapshot = ghBody.pathSnapshot || params.pathSnapshot || ('data/feed-' + new Date().toISOString().slice(0,10) + '.json');\nconst base = ghBody.base || ('https://api.github.com/repos/' + owner + '/' + repo + '/contents');\n\nconst newItems = (()=>{ try{ const j=JSON.parse(Buffer.from(ghBody.content||'', 'base64').toString('utf8')); return Array.isArray(j)? j : (j && j.articles)? j.articles : []; }catch(_){ return []; }})();\nconst oldItems = existingContentB64 ? decodeContent(existingContentB64) : [];\n\nif (!Array.isArray(oldItems) || oldItems.length===0) { /* ok */ }\nif (!Array.isArray(newItems) || newItems.length===0) { /* ok */ }\nif ((oldItems?.length||0)===0 && (newItems?.length||0)===0) { return []; }\nconst seen=new Set();\nconst merged=[];\nfor(const it of oldItems){ if(it && it.url && !seen.has(it.url)){ seen.add(it.url); merged.push(it); } }\nfor(const it of newItems){ if(it && it.url && !seen.has(it.url)){ seen.add(it.url); merged.push(it); } }\nmerged.sort((a,b)=> new Date(b.published_at)-new Date(a.published_at) || (b.relevance||0)-(a.relevance||0));\nconst cap = Number((item('BUILD_PARAMS')||{}).params?.feedMaxSnapshot||500);\nmerged.splice(cap);\nconst content = Buffer.from(JSON.stringify({ version:'v1.0', articles: merged }, null, 2)).toString('base64');\nconst message = 'chore(feed): snapshot ' + pathSnapshot;\nconst body = { message, content, branch };\nif (sha) body.sha = sha;\nreturn [{ json: { url: base + '/' + pathSnapshot, body: body } }];\n"
      },
      "id": "5613e606-0909-4bc2-80f3-0be6aacee00a",
      "name": "BUILD_PUT_SNAPSHOT",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -720,
        -256
      ]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "={{$json.url}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.body }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "c88e4ad3-ea59-4bac-b583-fbeb2b2a4b89",
      "name": "GITHUB_PUT_SNAPSHOT",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -544,
        -272
      ],
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      },
      "notes": "Writes daily snapshot: data/feed-YYYY-MM-DD.json"
    },
    {
      "parameters": {
        "options": {
          "responseCode": 200
        }
      },
      "id": "3dc7dd72-bc2d-4967-9392-8b36a73e0d86",
      "name": "RESPOND (FEED_IN)",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        16,
        -96
      ]
    },
    {
      "parameters": {
        "jsCode": "// BUILD_ENTRY_FILES — produce one GitHub file per article (persistent entries); skip if no articles\nfunction item(n){ try{ const it=$items(n,0,0); return it && it.json ? it.json : null; }catch(_){ return null; } }\nconst pItem = item('BUILD_PARAMS') || {};\nconst params = (pItem.params) || {};\nconst owner = params.repoOwner || 'vulcanoai';\nconst repo  = params.repoName  || 'vulcanoai.github.io';\nconst branch= params.branch     || 'main';\nconst base  = `https://api.github.com/repos/${owner}/${repo}/contents`;\n// Prefer input items, fallback to $json.articles if needed\nconst inputItems = $input.all();\nlet arts = Array.isArray(inputItems[0]?.json?.articles) ? inputItems[0].json.articles : (Array.isArray($json.articles) ? $json.articles : []);\nif (!arts.length) return [];\n\nfunction slugify(s){ return (s||'').toString().normalize('NFD').replace(/[\\u0300-\\u036f]/g,'').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'').slice(0,80); }\nfunction shortHash(s){ let h=0; for (let i=0;i<(s||'').length;i++){ h=((h<<5)-h) + s.charCodeAt(i); h|=0; } return ('00000000'+(h>>>0).toString(16)).slice(-8); }\n\nconst out = [];\nfor (const a of arts){\n  if (!a || !a.url || !a.title) continue;\n  const dateStr = (a.published_at || new Date().toISOString()).slice(0,10);\n  const slug = slugify(a.title);\n  const uniq = shortHash(a.url);\n  const path = `data/entries/${dateStr}/${slug}-${uniq}.json`;\n  const payload = JSON.stringify({\n    version: 'v1.0',\n    id: a.id || `${dateStr}-${slug}-${uniq}`,\n    title: a.title, summary: a.summary || '', url: a.url,\n    source: a.source || '', source_url: a.source_url || '',\n    country: a.country || 'Regional', topics: a.topics || [],\n    language: a.language || 'es', published_at: a.published_at || new Date().toISOString(),\n    relevance: a.relevance || 0, sentiment: a.sentiment || 'neutral',\n    author: a.author || '', curator: a.curator || 'Luciano AI'\n  }, null, 2);\n  const content = Buffer.from(payload).toString('base64');\n  const message = `feat(news): add entry ${slug} (${dateStr})`;\n  out.push({ json: { base, branch, path, content, payload, message } });\n}\nreturn out;"
      },
      "id": "b81a689a-dc2c-4aca-8119-9ab6be63024c",
      "name": "BUILD_ENTRY_FILES",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1136,
        320
      ]
    },
    {
      "parameters": {
        "url": "={{$json.base}}/{{ $json.path }}?ref={{$json.branch}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            }
          ]
        },
        "options": {
          "timeout": 60000
        }
      },
      "id": "f998444f-160c-4523-8256-607fbe3fbdee",
      "name": "GITHUB_GET_ENTRY_SHA",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -912,
        320
      ],
      "alwaysOutputData": true,
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      },
      "continueOnFail": true,
      "notes": "Read entry file sha if exists (per-article)."
    },
    {
      "parameters": {
        "mode": "mergeByPosition",
        "options": {}
      },
      "id": "06d9599c-eeed-4467-a159-6953d13f1da2",
      "name": "ENTRY_SHA_MERGE",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        -528,
        304
      ]
    },
    {
      "parameters": {
        "jsCode": "// BUILD_PUT_ENTRY — assemble PUT body for per-article file\\nconst r = ($json && typeof $json === 'object') ? ($json.body && typeof $json.body === 'object' ? $json.body : ($json.data && typeof $json.data === 'object' ? $json.data : $json)) : {};\nconst sha = (typeof r.sha === 'string') ? r.sha : undefined;\\nconst { base, branch, path, content, message } = $json;\\nconst body = { message, content, branch };\\nif (sha) body.sha = sha;\\nreturn [{ json: { url: `${base}/${path}`, body } }];"
      },
      "id": "507ab769-5e5f-4bf3-b03b-d0191ca8d6fb",
      "name": "BUILD_PUT_ENTRY",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        128,
        80
      ]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "={{$json.url}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.body }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "ec4ab217-8545-4f36-8420-999f537cdbdb",
      "name": "GITHUB_PUT_ENTRY",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        608,
        352
      ],
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      },
      "notes": "Create/update per-article persistent entry under data/entries/YYYY-MM-DD/slug-hash.json"
    },
    {
      "parameters": {
        "jsCode": "// DIRECT_NORMALIZE — minimal normalization, never drop valid items\nconst arr = Array.isArray($json.articles) ? $json.articles : [];\nfunction norm(a){\n  const title = a.title || a.titulo || '';\n  const url = a.url || a.link || '';\n  if (!title || !url) return null;\n  const lang = (a.language || a.idioma || 'es').toString().slice(0,2).toLowerCase();\n  let pub = a.published_at || a.fecha || new Date().toISOString();\n  const d = new Date(pub); if (!isFinite(d)) pub = new Date().toISOString();\n  const topics = Array.isArray(a.topics) ? a.topics : (Array.isArray(a.temas) ? a.temas : []);\n  return {\n    id: a.id || url || title,\n    title, summary: a.summary || a.resumen || '', url,\n    source: a.source || a.fuente || '', source_url: a.source_url || a.fuente_url || '',\n    country: a.country || a.pais || 'Regional', topics,\n    language: lang, published_at: pub,\n    relevance: a.relevance || a.relevancia || 0, sentiment: a.sentiment || a.sentimiento || 'neutral',\n    author: a.author || a.autor || '', curator: a.curator || a.curador || 'Luciano AI'\n  };\n}\nconst articles = arr.map(norm).filter(Boolean);\nreturn [{ json: { articles, count: articles.length, timestamp: new Date().toISOString() } }];"
      },
      "id": "1fd0ca6d-c99e-4cdd-8101-601cc86db9e3",
      "name": "DIRECT_NORMALIZE",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1584,
        480
      ]
    },
    {
      "parameters": {
        "jsCode": "// BUILD_RUN_FILE — unique snapshot per trigger run\nfunction item(n){ try{ const it=$items(n,0,0); return it && it.json ? it.json : null; }catch(_){ return null; } }\nconst p = item('BUILD_PARAMS') || {};\nconst params = p.params || {};\nconst owner = params.repoOwner || 'vulcanoai';\nconst repo  = params.repoName  || 'vulcanoai.github.io';\nconst branch= params.branch     || 'main';\nconst base  = `https://api.github.com/repos/${owner}/${repo}/contents`;\nconst runId = (new Date().toISOString()).replace(/[:.]/g,'-');\nconst path  = `data/runs/${runId}.json`;\nconst payload = JSON.stringify({ version: 'v1.0', articles: $json.articles || [], count: $json.count || 0, timestamp: $json.timestamp, params }, null, 2);\nconst content = Buffer.from(payload).toString('base64');\nconst message = `feat(run): snapshot ${runId} (${($json.count||0)} articles)`;\nreturn [{ json: { url: `${base}/${path}`, body: { message, content, branch } } }];"
      },
      "id": "cb197cc5-799f-427c-9892-7d0566a03c90",
      "name": "BUILD_RUN_FILE",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1456,
        896
      ]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "={{$json.url}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.body }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "7bd599cb-f065-41ab-882c-984a8c81f393",
      "name": "GITHUB_PUT_RUN",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -1168,
        864
      ],
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// BUILD_MASTER_INDEX — by-topic and by-country (today); emits two items\nconst arts = Array.isArray($json.articles) ? $json.articles : [];\nconst topics = new Map();\nconst countries = new Map();\nfor (const a of arts){\n  for (const t of (a.topics||[])) topics.set(t, (topics.get(t)||0)+1);\n  const c = a.country || 'Regional'; countries.set(c, (countries.get(c)||0)+1);\n}\nconst byTopic = Object.fromEntries([...topics.entries()].sort());\nconst byCountry = Object.fromEntries([...countries.entries()].sort());\nconst gen = new Date().toISOString();\nfunction paramsOf(name){ try{ const it=$items(name,0,0); return it && it.json && it.json.params ? it.json.params : {}; }catch(_){ return {}; } }\nconst p = paramsOf('BUILD_PARAMS');\nconst owner=p.repoOwner||'vulcanoai'; const repo=p.repoName||'vulcanoai.github.io'; const branch=p.branch||'main';\nconst base=`https://api.github.com/repos/${owner}/${repo}/contents`;\nconst tPayload = JSON.stringify({ version:'v1.0', generated_at: gen, byTopic }, null, 2);\nconst cPayload = JSON.stringify({ version:'v1.0', generated_at: gen, byCountry }, null, 2);\nconst tContent = Buffer.from(tPayload).toString('base64');\nconst cContent = Buffer.from(cPayload).toString('base64');\nreturn [\n  { json:{ base, branch, path:'data/index/by-topic.json', content: tContent, message:'chore(index): by-topic' } },\n  { json:{ base, branch, path:'data/index/by-country.json', content: cContent, message:'chore(index): by-country' } }\n];"
      },
      "id": "28f723c3-9c84-411d-b934-84e1ef713302",
      "name": "BUILD_MASTER_INDEX",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1120,
        672
      ]
    },
    {
      "parameters": {
        "url": "={{$json.base}}/{{ $json.path }}?ref={{$json.branch}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            }
          ]
        },
        "options": {
          "timeout": 60000
        }
      },
      "id": "b55e3d4b-c7f8-4d3c-86cb-6e50ff6bd60c",
      "name": "GITHUB_GET_BY_TOPIC_SHA",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -816,
        864
      ],
      "alwaysOutputData": true,
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// BUILD_PUT_GENERIC — merge meta + sha from both inputs into PUT body\nconst all = $input.all();\nconst meta = all.find(i => i.json && i.json.base && i.json.path);\nif (!meta) return [];\nfunction respOf(it){ const j = it && it.json; if(!j) return {}; if(j.body && typeof j.body==='object') return j.body; if(j.data && typeof j.data==='object') return j.data; return j; }\nconst shaItem = all.find(i => { const r = respOf(i); return r && typeof r.sha === 'string'; });\nconst r = shaItem ? respOf(shaItem) : {};\nconst { base, branch, path, content, message } = meta.json;\nconst body = { message, content, branch };\nif (typeof r.sha === 'string') body.sha = r.sha;\nreturn [{ json: { url: `${base}/${path}`, body } }];\n"
      },
      "id": "4a280292-b25c-4f8a-8e44-afabbf4838c7",
      "name": "BUILD_PUT_BY_TOPIC",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -80,
        816
      ]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "={{$json.url}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.body }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "1fb5c24f-9a92-4900-9a61-3f9fc2382183",
      "name": "GITHUB_PUT_BY_TOPIC",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        80,
        816
      ],
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      }
    },
    {
      "parameters": {
        "url": "={{$json.base}}/{{ $json.path }}?ref={{$json.branch}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            }
          ]
        },
        "options": {
          "timeout": 60000
        }
      },
      "id": "82a72766-941e-48a3-a728-bcf39147ee35",
      "name": "GITHUB_GET_BY_COUNTRY_SHA",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -832,
        1040
      ],
      "alwaysOutputData": true,
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// BUILD_PUT_GENERIC — merge meta + sha from both inputs into PUT body\nconst all = $input.all();\nconst meta = all.find(i => i.json && i.json.base && i.json.path);\nif (!meta) return [];\nfunction respOf(it){ const j = it && it.json; if(!j) return {}; if(j.body && typeof j.body==='object') return j.body; if(j.data && typeof j.data==='object') return j.data; return j; }\nconst shaItem = all.find(i => { const r = respOf(i); return r && typeof r.sha === 'string'; });\nconst r = shaItem ? respOf(shaItem) : {};\nconst { base, branch, path, content, message } = meta.json;\nconst body = { message, content, branch };\nif (typeof r.sha === 'string') body.sha = r.sha;\nreturn [{ json: { url: `${base}/${path}`, body } }];\n"
      },
      "id": "d21b51d7-1c43-465e-846a-b21fece3eaa5",
      "name": "BUILD_PUT_BY_COUNTRY",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        32,
        1024
      ]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "={{$json.url}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.body }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "6b615c96-4bef-4160-ae1c-0c65be35f1c8",
      "name": "GITHUB_PUT_BY_COUNTRY",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        384,
        944
      ],
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// BUILD_CATALOG — list available day partitions (seed with today)\nconst today = new Date().toISOString().slice(0,10);\nfunction paramsOf(name){ try{ const it=$items(name,0,0); return it && it.json && it.json.params ? it.json.params : {}; }catch(_){ return {}; } }\nconst p = paramsOf('BUILD_PARAMS');\nconst owner=p.repoOwner||'vulcanoai'; const repo=p.repoName||'vulcanoai.github.io'; const branch=p.branch||'main';\nconst base=`https://api.github.com/repos/${owner}/${repo}/contents`;\nconst payload = JSON.stringify({ version:'v1.0', generated_at:new Date().toISOString(), days:[ today ] }, null, 2);\nconst content = Buffer.from(payload).toString('base64');\nreturn [{ json:{ base, branch, path:'data/index/catalog.json', content, message:'chore(index): catalog' } }];"
      },
      "id": "591d339d-4b1c-4ac9-a5b3-47b9083de73e",
      "name": "BUILD_CATALOG",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1136,
        1040
      ]
    },
    {
      "parameters": {
        "url": "={{$json.base}}/{{ $json.path }}?ref={{$json.branch}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            }
          ]
        },
        "options": {
          "timeout": 60000
        }
      },
      "id": "97962840-b1bb-462d-a586-56eca2639b9c",
      "name": "GITHUB_GET_CATALOG_SHA",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -912,
        1264
      ],
      "alwaysOutputData": true,
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// BUILD_PUT_GENERIC — merge meta + sha from both inputs into PUT body\nconst all = $input.all();\nconst meta = all.find(i => i.json && i.json.base && i.json.path);\nif (!meta) return [];\nfunction respOf(it){ const j = it && it.json; if(!j) return {}; if(j.body && typeof j.body==='object') return j.body; if(j.data && typeof j.data==='object') return j.data; return j; }\nconst shaItem = all.find(i => { const r = respOf(i); return r && typeof r.sha === 'string'; });\nconst r = shaItem ? respOf(shaItem) : {};\nconst { base, branch, path, content, message } = meta.json;\nconst body = { message, content, branch };\nif (typeof r.sha === 'string') body.sha = r.sha;\nreturn [{ json: { url: `${base}/${path}`, body } }];\n"
      },
      "id": "540483d0-d354-4754-8553-dfd7d27a231c",
      "name": "BUILD_PUT_CATALOG",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        32,
        1280
      ]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "={{$json.url}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.body }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "2d40eb24-b0e5-41a6-9e12-9572ed622f00",
      "name": "GITHUB_PUT_CATALOG",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        288,
        1136
      ],
      "credentials": {
        "githubApi": {
          "id": "fiWvt8LJXl85zjSx",
          "name": "GitHub account"
        }
      }
    },
    {
      "parameters": {
        "mode": "mergeByPosition",
        "options": {}
      },
      "id": "6b0963a5-cac6-4b3b-be8c-d69d2369d019",
      "name": "BY_TOPIC_SHA_MERGE",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        -416,
        848
      ]
    },
    {
      "parameters": {
        "mode": "mergeByPosition",
        "options": {}
      },
      "id": "813dadab-f579-4799-9a1e-58576db7e16b",
      "name": "BY_COUNTRY_SHA_MERGE",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        -240,
        1056
      ]
    },
    {
      "parameters": {
        "mode": "mergeByPosition",
        "options": {}
      },
      "id": "e56dc006-e4a4-4538-9758-6869eaa6628c",
      "name": "CATALOG_SHA_MERGE",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        -368,
        1280
      ]
    },
    {
      "parameters": {
        "url": "={{ 'https://raw.githubusercontent.com/' + $items('BUILD_PARAMS',0,0).json.params.repoOwner + '/' + $items('BUILD_PARAMS',0,0).json.params.repoName + '/' + $items('BUILD_PARAMS',0,0).json.params.branch + '/data/sources.json' }}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "0a1f2e3d-4c5b-6a7d-8e9f-0a1b2c3d4e5f",
      "name": "GET_ALLOWLIST",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -2112,
        -80
      ]
    },
    {
      "parameters": {
        "jsCode": "function host(u){ try{ const h=new URL(u).hostname.toLowerCase(); return h.startsWith('www.')?h.slice(4):h; }catch{ return ''; } }\nfunction loadList(){ try{ const it=$items('GET_ALLOWLIST',0,0); const raw=(it.json||it.body||it.data); const arr=Array.isArray(raw)?raw:JSON.parse(typeof raw==='string'?raw:JSON.stringify(raw)); const set=new Set(); for(const s of arr){ const h=host(s.url||s.source_url||''); if(h) set.add(h);} return set; }catch(_) { return new Set(); } }\nconst allow=loadList(); const arr=Array.isArray($json.articles)?$json.articles:[]; const out=[]; for(const a of arr){ const h=host(a.url||''); if(!h) continue; if(allow.size && !allow.has(h)){ let ok=false; for(const x of allow){ if(h===x || h.endsWith('.'+x)){ ok=true; break; } } if(!ok) continue; } out.push(a);} return [{ json:{...$json, articles:out, count:out.length} }];"
      },
      "id": "1a2b3c4d-5e6f-7081-92ab-3c4d5e6f7081",
      "name": "FILTER_ALLOWLIST",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1408,
        320
      ]
    },
    {
      "parameters": {
        "jsCode": "function host(u){ try{ const h=new URL(u).hostname.toLowerCase(); return h.startsWith('www.')?h.slice(4):h; }catch{ return ''; } }\nfunction nTitle(t){ return (t||'').toString().normalize('NFD').replace(/[\\u0300-\\u036f]/g,'').toLowerCase().replace(/[^a-z0-9\\s]+/g,' ').replace(/\\s+/g,' ').trim(); }\nconst STOP=new Set(['de','del','la','el','los','las','en','y','para','por','un','una','unos','unas','con','sobre','se','al','lo','a','que','su','sus','es','ai','ia']);\nfunction tKey(t){ const v=nTitle(t).split(' ').filter(w=>w && !STOP.has(w) && w.length>=3); return v.slice(0,10).join(' ');}\nconst arr=Array.isArray($json.articles)?$json.articles:[]; const best=new Map(); for(const a of arr){ const h=host(a.url||''); const k=tKey(a.title||''); const key= h&&k ? (h+'|'+k) : (a.url||a.id||a.title||''); const prev=best.get(key); if(!prev){ best.set(key,a); continue;} const at=new Date(a.published_at).getTime(); const pt=new Date(prev.published_at).getTime(); best.set(key,(isFinite(at)&&isFinite(pt)&&at>pt)?a:prev);} const out=Array.from(best.values()); return [{ json:{...$json, articles:out, count:out.length} }];"
      },
      "id": "9b8c7d6e-5f4a-3b2c-1a09-876543210abc",
      "name": "DEDUP_BY_HOST_TITLE",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1200,
        320
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "INDEX_SHA_MERGE3": {
      "main": [
        [
          {
            "node": "BUILD_PUT_DAILY_INDEX",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AUTOPILOT (hourly)": {
      "main": [
        [
          {
            "node": "START",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BUILD_DAILY_INDEX": {
      "main": [
        [
          {
            "node": "GITHUB_GET_DAILY_INDEX_SHA",
            "type": "main",
            "index": 0
          },
          {
            "node": "INDEX_SHA_MERGE3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GITHUB_GET_DAILY_INDEX_SHA": {
      "main": [
        [
          {
            "node": "INDEX_SHA_MERGE3",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "BUILD_PUT_DAILY_INDEX": {
      "main": [
        [
          {
            "node": "GITHUB_PUT_DAILY_INDEX",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GITHUB_GET_SNAPSHOT_SHA": {
      "main": [
        [
          {
            "node": "BUILD_PUT_SNAPSHOT",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FEED_IN": {
      "main": [
        [
          {
            "node": "START",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "START": {
      "main": [
        [
          {
            "node": "BUILD_PARAMS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BUILD_PARAMS": {
      "main": [
        [
          {
            "node": "AGENT — Research",
            "type": "main",
            "index": 0
          },
          {
            "node": "GET_ALLOWLIST",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "xAI Grok Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AGENT — Research",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Aether Memory": {
      "ai_memory": [
        [
          {
            "node": "AGENT — Research",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "AGENT — Research": {
      "main": [
        [
          {
            "node": "PARSE_AGENT_JSON (safe)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PARSE_AGENT_JSON (safe)": {
      "main": [
        [
          {
            "node": "VALIDATE_DEDUPE_SORT",
            "type": "main",
            "index": 0
          },
          {
            "node": "DIRECT_NORMALIZE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BUILD_GH_BODY": {
      "main": [
        [
          {
            "node": "GITHUB_GET_LATEST_SHA",
            "type": "main",
            "index": 0
          },
          {
            "node": "GITHUB_GET_SNAPSHOT_SHA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GITHUB_GET_LATEST_SHA": {
      "main": [
        [
          {
            "node": "BUILD_PUT_LATEST",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BUILD_PUT_LATEST": {
      "main": [
        [
          {
            "node": "GITHUB_PUT_LATEST",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GITHUB_PUT_LATEST": {
      "main": [
        [
          {
            "node": "RESPOND (FEED_IN)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BUILD_PUT_SNAPSHOT": {
      "main": [
        [
          {
            "node": "GITHUB_PUT_SNAPSHOT",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BUILD_ENTRY_FILES": {
      "main": [
        [
          {
            "node": "GITHUB_GET_ENTRY_SHA",
            "type": "main",
            "index": 0
          },
          {
            "node": "ENTRY_SHA_MERGE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GITHUB_GET_ENTRY_SHA": {
      "main": [
        [
          {
            "node": "ENTRY_SHA_MERGE",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "ENTRY_SHA_MERGE": {
      "main": [
        [
          {
            "node": "BUILD_PUT_ENTRY",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BUILD_PUT_ENTRY": {
      "main": [
        [
          {
            "node": "GITHUB_PUT_ENTRY",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DIRECT_NORMALIZE": {
      "main": [
        [
          {
            "node": "FILTER_ALLOWLIST",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BUILD_RUN_FILE": {
      "main": [
        [
          {
            "node": "GITHUB_PUT_RUN",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GITHUB_GET_BY_TOPIC_SHA": {
      "main": [
        [
          {
            "node": "BY_TOPIC_SHA_MERGE",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "BUILD_PUT_BY_TOPIC": {
      "main": [
        [
          {
            "node": "GITHUB_PUT_BY_TOPIC",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GITHUB_GET_BY_COUNTRY_SHA": {
      "main": [
        [
          {
            "node": "BY_COUNTRY_SHA_MERGE",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "BUILD_PUT_BY_COUNTRY": {
      "main": [
        [
          {
            "node": "GITHUB_PUT_BY_COUNTRY",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BUILD_MASTER_INDEX": {
      "main": [
        [
          {
            "node": "GITHUB_GET_BY_TOPIC_SHA",
            "type": "main",
            "index": 0
          },
          {
            "node": "GITHUB_GET_BY_COUNTRY_SHA",
            "type": "main",
            "index": 0
          },
          {
            "node": "BY_TOPIC_SHA_MERGE",
            "type": "main",
            "index": 0
          },
          {
            "node": "BY_COUNTRY_SHA_MERGE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GITHUB_GET_CATALOG_SHA": {
      "main": [
        [
          {
            "node": "CATALOG_SHA_MERGE",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "BUILD_PUT_CATALOG": {
      "main": [
        [
          {
            "node": "GITHUB_PUT_CATALOG",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BUILD_CATALOG": {
      "main": [
        [
          {
            "node": "GITHUB_GET_CATALOG_SHA",
            "type": "main",
            "index": 0
          },
          {
            "node": "CATALOG_SHA_MERGE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BY_TOPIC_SHA_MERGE": {
      "main": [
        [
          {
            "node": "BUILD_PUT_BY_TOPIC",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BY_COUNTRY_SHA_MERGE": {
      "main": [
        [
          {
            "node": "BUILD_PUT_BY_COUNTRY",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CATALOG_SHA_MERGE": {
      "main": [
        [
          {
            "node": "BUILD_PUT_CATALOG",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FILTER_ALLOWLIST": {
      "main": [
        [
          {
            "node": "DEDUP_BY_HOST_TITLE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DEDUP_BY_HOST_TITLE": {
      "main": [
        [
          {
            "node": "BUILD_ENTRY_FILES",
            "type": "main",
            "index": 0
          },
          {
            "node": "BUILD_DAILY_INDEX",
            "type": "main",
            "index": 0
          },
          {
            "node": "BUILD_RUN_FILE",
            "type": "main",
            "index": 0
          },
          {
            "node": "BUILD_GH_BODY",
            "type": "main",
            "index": 0
          },
          {
            "node": "BUILD_MASTER_INDEX",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner"
  },
  "versionId": "9a00f5df-1b8b-41e5-b493-43c3285461cb",
  "meta": {
    "instanceId": "99f6164f62c22d699c9ce9932f4b521d20a24970022054dc68b9a0dd16ce6d86"
  },
  "id": "tshQmJwZGsuggmaM",
  "tags": []
}